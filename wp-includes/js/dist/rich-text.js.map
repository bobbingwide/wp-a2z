{"version":3,"sources":["webpack://wp.[name]/webpack/bootstrap","webpack://wp.[name]/./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","webpack://wp.[name]/./node_modules/@babel/runtime/helpers/esm/defineProperty.js","webpack://wp.[name]/./node_modules/@babel/runtime/helpers/esm/iterableToArray.js","webpack://wp.[name]/./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","webpack://wp.[name]/./node_modules/@babel/runtime/helpers/esm/objectSpread.js","webpack://wp.[name]/./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","webpack://wp.[name]/./node_modules/@babel/runtime/helpers/esm/typeof.js","webpack://wp.[name]//Users/riad/Workspace/a8c/gutenberg/packages/rich-text/src/apply-format.js","webpack://wp.[name]//Users/riad/Workspace/a8c/gutenberg/packages/rich-text/src/concat.js","webpack://wp.[name]//Users/riad/Workspace/a8c/gutenberg/packages/rich-text/src/create-element.js","webpack://wp.[name]//Users/riad/Workspace/a8c/gutenberg/packages/rich-text/src/create.js","webpack://wp.[name]//Users/riad/Workspace/a8c/gutenberg/packages/rich-text/src/get-active-format.js","webpack://wp.[name]//Users/riad/Workspace/a8c/gutenberg/packages/rich-text/src/get-text-content.js","webpack://wp.[name]//Users/riad/Workspace/a8c/gutenberg/packages/rich-text/src/index.js","webpack://wp.[name]//Users/riad/Workspace/a8c/gutenberg/packages/rich-text/src/insert.js","webpack://wp.[name]//Users/riad/Workspace/a8c/gutenberg/packages/rich-text/src/is-collapsed.js","webpack://wp.[name]//Users/riad/Workspace/a8c/gutenberg/packages/rich-text/src/is-empty.js","webpack://wp.[name]//Users/riad/Workspace/a8c/gutenberg/packages/rich-text/src/is-format-equal.js","webpack://wp.[name]//Users/riad/Workspace/a8c/gutenberg/packages/rich-text/src/join.js","webpack://wp.[name]//Users/riad/Workspace/a8c/gutenberg/packages/rich-text/src/normalise-formats.js","webpack://wp.[name]//Users/riad/Workspace/a8c/gutenberg/packages/rich-text/src/remove-format.js","webpack://wp.[name]//Users/riad/Workspace/a8c/gutenberg/packages/rich-text/src/remove.js","webpack://wp.[name]//Users/riad/Workspace/a8c/gutenberg/packages/rich-text/src/replace.js","webpack://wp.[name]//Users/riad/Workspace/a8c/gutenberg/packages/rich-text/src/slice.js","webpack://wp.[name]//Users/riad/Workspace/a8c/gutenberg/packages/rich-text/src/split.js","webpack://wp.[name]//Users/riad/Workspace/a8c/gutenberg/packages/rich-text/src/to-dom.js","webpack://wp.[name]//Users/riad/Workspace/a8c/gutenberg/packages/rich-text/src/to-html-string.js","webpack://wp.[name]//Users/riad/Workspace/a8c/gutenberg/packages/rich-text/src/to-tree.js","webpack://wp.[name]/external {\"this\":[\"wp\",\"escapeHtml\"]}","webpack://wp.[name]/external \"lodash\""],"names":["applyFormat","format","formats","text","start","end","startIndex","endIndex","newFormats","slice","startFormat","find","type","applyFormats","index","normaliseFormats","newFormatsAtIndex","filter","push","concat","values","reduce","accumlator","createElement","html","implementation","createHTMLDocument","body","innerHTML","window","Node","TEXT_NODE","ELEMENT_NODE","createEmptyValue","create","element","range","multilineTag","removeNode","unwrapNode","filterString","removeAttribute","length","Array","document","createFromElement","createFromMultilineElement","accumulateSelection","accumulator","node","value","parentNode","startContainer","startOffset","endContainer","endOffset","currentLength","undefined","childNodes","filterRange","nodeValue","hasChildNodes","filterStringComplete","string","replace","nodeType","nodeName","lastFormats","lastFormat","toLowerCase","attributes","getAttributes","newFormat","isFormatEqual","isEmpty","object","unshift","i","formatIndex","children","hasAttributes","name","getActiveFormat","formatType","getTextContent","insert","valueToInsert","isCollapsed","isEmptyLine","format1","format2","attributes1","attributes2","keys1","Object","keys","keys2","join","separator","forEach","formatsAtIndex","lastFormatsAtIndex","removeFormat","filterFormats","remove","pattern","replacement","match","rest","offset","newText","fill","split","splitAtSelection","arguments","nextStart","map","substring","before","after","createPathToNode","rootNode","path","previousSibling","getNodeByPath","shift","createEmpty","appendChild","ownerDocument","append","child","createTextNode","key","setAttribute","appendText","appendData","getLastChild","lastChild","getParent","isText","getText","removeChild","toDom","startPath","endPath","tree","toTree","onStartIndex","pointer","multilineIndex","onEndIndex","onEmpty","br","selection","apply","current","applyValue","applySelection","future","firstChild","currentChild","futureNodeType","replaceChild","windowSelection","getSelection","createRange","collapsed","insertData","setStart","setEnd","removeAllRanges","addRange","toHTMLString","createChildrenHTML","parent","indexOf","splice","createElementHTML","attributeString","isValidAttributeName","escapeAttribute","escapeHTML","settings","piece","tag","formatsLength","character","charAt","characterFormats","lastCharacterFormats","newNode"],"mappings":"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","file":"rich-text.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./node_modules/@wordpress/rich-text/build-module/index.js\");\n","export default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","export default function _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}","import defineProperty from \"./defineProperty\";\nexport default function _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}","import arrayWithoutHoles from \"./arrayWithoutHoles\";\nimport iterableToArray from \"./iterableToArray\";\nimport nonIterableSpread from \"./nonIterableSpread\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();\n}","function _typeof2(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof2(obj); }\n\nexport default function _typeof(obj) {\n  if (typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return _typeof2(obj);\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n    };\n  }\n\n  return _typeof(obj);\n}","/**\n * External dependencies\n */\n\nimport { find } from 'lodash';\n\n/**\n * Internal dependencies\n */\n\nimport { normaliseFormats } from './normalise-formats';\n\n/**\n * Apply a format object to a Rich Text value from the given `startIndex` to the\n * given `endIndex`. Indices are retrieved from the selection if none are\n * provided.\n *\n * @param {Object} value      Value to modify.\n * @param {Object} format     Format to apply.\n * @param {number} startIndex Start index.\n * @param {number} endIndex   End index.\n *\n * @return {Object} A new value with the format applied.\n */\nexport function applyFormat(\n\t{ formats, text, start, end },\n\tformat,\n\tstartIndex = start,\n\tendIndex = end\n) {\n\tconst newFormats = formats.slice( 0 );\n\n\t// If the selection is collapsed, expand start and end to the edges of the\n\t// format.\n\tif ( startIndex === endIndex ) {\n\t\tconst startFormat = find( newFormats[ startIndex ], { type: format.type } );\n\n\t\twhile ( find( newFormats[ startIndex ], startFormat ) ) {\n\t\t\tapplyFormats( newFormats, startIndex, format );\n\t\t\tstartIndex--;\n\t\t}\n\n\t\tendIndex++;\n\n\t\twhile ( find( newFormats[ endIndex ], startFormat ) ) {\n\t\t\tapplyFormats( newFormats, endIndex, format );\n\t\t\tendIndex++;\n\t\t}\n\t} else {\n\t\tfor ( let index = startIndex; index < endIndex; index++ ) {\n\t\t\tapplyFormats( newFormats, index, format );\n\t\t}\n\t}\n\n\treturn normaliseFormats( { formats: newFormats, text, start, end } );\n}\n\nfunction applyFormats( formats, index, format ) {\n\tif ( formats[ index ] ) {\n\t\tconst newFormatsAtIndex = formats[ index ].filter( ( { type } ) => type !== format.type );\n\t\tnewFormatsAtIndex.push( format );\n\t\tformats[ index ] = newFormatsAtIndex;\n\t} else {\n\t\tformats[ index ] = [ format ];\n\t}\n}\n","/**\n * Internal dependencies\n */\n\nimport { normaliseFormats } from './normalise-formats';\n\n/**\n * Combine all Rich Text values into one. This is similar to\n * `String.prototype.concat`.\n *\n * @param {...[object]} values An array of all values to combine.\n *\n * @return {Object} A new value combining all given records.\n */\nexport function concat( ...values ) {\n\treturn normaliseFormats( values.reduce( ( accumlator, { formats, text } ) => ( {\n\t\ttext: accumlator.text + text,\n\t\tformats: accumlator.formats.concat( formats ),\n\t} ) ) );\n}\n","/**\n * Parse the given HTML into a body element.\n *\n * @param {HTMLDocument} document The HTML document to use to parse.\n * @param {string}       html     The HTML to parse.\n *\n * @return {HTMLBodyElement} Body element with parsed HTML.\n */\nexport function createElement( { implementation }, html ) {\n\tconst { body } = implementation.createHTMLDocument( '' );\n\tbody.innerHTML = html;\n\treturn body;\n}\n","/**\n * Internal dependencies\n */\n\nimport { isEmpty } from './is-empty';\nimport { isFormatEqual } from './is-format-equal';\nimport { createElement } from './create-element';\n\n/**\n * Browser dependencies\n */\n\nconst { TEXT_NODE, ELEMENT_NODE } = window.Node;\n\nfunction createEmptyValue() {\n\treturn { formats: [], text: '' };\n}\n\n/**\n * Create a RichText value from an `Element` tree (DOM), an HTML string or a\n * plain text string, with optionally a `Range` object to set the selection. If\n * called without any input, an empty value will be created. If\n * `multilineTag` is provided, any content of direct children whose type matches\n * `multilineTag` will be separated by two newlines. The optional functions can\n * be used to filter out content.\n *\n * @param {?Object}   $1                 Optional named argements.\n * @param {?Element}  $1.element         Element to create value from.\n * @param {?string}   $1.text            Text to create value from.\n * @param {?string}   $1.html            HTML to create value from.\n * @param {?Range}    $1.range           Range to create value from.\n * @param {?string}   $1.multilineTag    Multiline tag if the structure is\n *                                       multiline.\n * @param {?Function} $1.removeNode      Function to declare whether the given\n *                                       node should be removed.\n * @param {?Function} $1.unwrapNode      Function to declare whether the given\n *                                       node should be unwrapped.\n * @param {?Function} $1.filterString    Function to filter the given string.\n * @param {?Function} $1.removeAttribute Wether to remove an attribute based on\n *                                       the name.\n *\n * @return {Object} A rich text value.\n */\nexport function create( {\n\telement,\n\ttext,\n\thtml,\n\trange,\n\tmultilineTag,\n\tremoveNode,\n\tunwrapNode,\n\tfilterString,\n\tremoveAttribute,\n} = {} ) {\n\tif ( typeof text === 'string' && text.length > 0 ) {\n\t\treturn {\n\t\t\tformats: Array( text.length ),\n\t\t\ttext: text,\n\t\t};\n\t}\n\n\tif ( typeof html === 'string' && html.length > 0 ) {\n\t\telement = createElement( document, html );\n\t}\n\n\tif ( typeof element !== 'object' ) {\n\t\treturn createEmptyValue();\n\t}\n\n\tif ( ! multilineTag ) {\n\t\treturn createFromElement( {\n\t\t\telement,\n\t\t\trange,\n\t\t\tremoveNode,\n\t\t\tunwrapNode,\n\t\t\tfilterString,\n\t\t\tremoveAttribute,\n\t\t} );\n\t}\n\n\treturn createFromMultilineElement( {\n\t\telement,\n\t\trange,\n\t\tmultilineTag,\n\t\tremoveNode,\n\t\tunwrapNode,\n\t\tfilterString,\n\t\tremoveAttribute,\n\t} );\n}\n\n/**\n * Helper to accumulate the value's selection start and end from the current\n * node and range.\n *\n * @param {Object} accumulator Object to accumulate into.\n * @param {Node}   node        Node to create value with.\n * @param {Range}  range       Range to create value with.\n * @param {Object} value       Value that is being accumulated.\n */\nfunction accumulateSelection( accumulator, node, range, value ) {\n\tif ( ! range ) {\n\t\treturn;\n\t}\n\n\tconst { parentNode } = node;\n\tconst { startContainer, startOffset, endContainer, endOffset } = range;\n\tconst currentLength = accumulator.text.length;\n\n\t// Selection can be extracted from value.\n\tif ( value.start !== undefined ) {\n\t\taccumulator.start = currentLength + value.start;\n\t// Range indicates that the current node has selection.\n\t} else if ( node === startContainer ) {\n\t\taccumulator.start = currentLength + startOffset;\n\t// Range indicates that the current node is selected.\n\t} else if (\n\t\tparentNode === startContainer &&\n\t\tnode === startContainer.childNodes[ startOffset ]\n\t) {\n\t\taccumulator.start = currentLength;\n\t}\n\n\t// Selection can be extracted from value.\n\tif ( value.end !== undefined ) {\n\t\taccumulator.end = currentLength + value.end;\n\t// Range indicates that the current node has selection.\n\t} else if ( node === endContainer ) {\n\t\taccumulator.end = currentLength + endOffset;\n\t// Range indicates that the current node is selected.\n\t} else if (\n\t\tparentNode === endContainer &&\n\t\tnode === endContainer.childNodes[ endOffset - 1 ]\n\t) {\n\t\taccumulator.end = currentLength + value.text.length;\n\t// Range indicates that the selection is before the current node.\n\t} else if (\n\t\tparentNode === endContainer &&\n\t\tnode === endContainer.childNodes[ endOffset ]\n\t) {\n\t\taccumulator.end = currentLength;\n\t}\n}\n\n/**\n * Adjusts the start and end offsets from a range based on a text filter.\n *\n * @param {Node}     node   Node of which the text should be filtered.\n * @param {Range}    range  The range to filter.\n * @param {Function} filter Function to use to filter the text.\n *\n * @return {?Object} Object containing range properties.\n */\nfunction filterRange( node, range, filter ) {\n\tif ( ! range ) {\n\t\treturn;\n\t}\n\n\tconst { startContainer, endContainer } = range;\n\tlet { startOffset, endOffset } = range;\n\n\tif ( node === startContainer ) {\n\t\tstartOffset = filter( node.nodeValue.slice( 0, startOffset ) ).length;\n\t}\n\n\tif ( node === endContainer ) {\n\t\tendOffset = filter( node.nodeValue.slice( 0, endOffset ) ).length;\n\t}\n\n\treturn { startContainer, startOffset, endContainer, endOffset };\n}\n\n/**\n * Creates a Rich Text value from a DOM element and range.\n *\n * @param {Object}    $1                 Named argements.\n * @param {?Element}  $1.element         Element to create value from.\n * @param {?Range}    $1.range           Range to create value from.\n * @param {?Function} $1.removeNode      Function to declare whether the given\n *                                       node should be removed.\n * @param {?Function} $1.unwrapNode      Function to declare whether the given\n *                                       node should be unwrapped.\n * @param {?Function} $1.filterString    Function to filter the given string.\n * @param {?Function} $1.removeAttribute Wether to remove an attribute based on\n *                                       the name.\n *\n * @return {Object} A rich text value.\n */\nfunction createFromElement( {\n\telement,\n\trange,\n\tremoveNode,\n\tunwrapNode,\n\tfilterString,\n\tremoveAttribute,\n} ) {\n\tconst accumulator = createEmptyValue();\n\n\tif ( ! element ) {\n\t\treturn accumulator;\n\t}\n\n\tif ( ! element.hasChildNodes() ) {\n\t\taccumulateSelection( accumulator, element, range, createEmptyValue() );\n\t\treturn accumulator;\n\t}\n\n\tconst length = element.childNodes.length;\n\n\t// Remove any line breaks in text nodes. They are not content, but used to\n\t// format the HTML. Line breaks in HTML are stored as BR elements.\n\t// See https://www.w3.org/TR/html5/syntax.html#newlines.\n\tconst filterStringComplete = ( string ) => {\n\t\tstring = string.replace( /[\\r\\n]/g, '' );\n\n\t\tif ( filterString ) {\n\t\t\tstring = filterString( string );\n\t\t}\n\n\t\treturn string;\n\t};\n\n\t// Optimise for speed.\n\tfor ( let index = 0; index < length; index++ ) {\n\t\tconst node = element.childNodes[ index ];\n\n\t\tif ( node.nodeType === TEXT_NODE ) {\n\t\t\tconst text = filterStringComplete( node.nodeValue );\n\t\t\trange = filterRange( node, range, filterStringComplete );\n\t\t\taccumulateSelection( accumulator, node, range, { text } );\n\t\t\taccumulator.text += text;\n\t\t\t// Create a sparse array of the same length as `text`, in which\n\t\t\t// formats can be added.\n\t\t\taccumulator.formats.length += text.length;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ( node.nodeType !== ELEMENT_NODE ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (\n\t\t\t( removeNode && removeNode( node ) ) ||\n\t\t\t( unwrapNode && unwrapNode( node ) && ! node.hasChildNodes() )\n\t\t) {\n\t\t\taccumulateSelection( accumulator, node, range, createEmptyValue() );\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ( node.nodeName === 'BR' ) {\n\t\t\taccumulateSelection( accumulator, node, range, createEmptyValue() );\n\t\t\taccumulator.text += '\\n';\n\t\t\taccumulator.formats.length += 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst lastFormats = accumulator.formats[ accumulator.formats.length - 1 ];\n\t\tconst lastFormat = lastFormats && lastFormats[ lastFormats.length - 1 ];\n\t\tlet format;\n\n\t\tif ( ! unwrapNode || ! unwrapNode( node ) ) {\n\t\t\tconst type = node.nodeName.toLowerCase();\n\t\t\tconst attributes = getAttributes( {\n\t\t\t\telement: node,\n\t\t\t\tremoveAttribute,\n\t\t\t} );\n\t\t\tconst newFormat = attributes ? { type, attributes } : { type };\n\n\t\t\t// Reuse the last format if it's equal.\n\t\t\tif ( isFormatEqual( newFormat, lastFormat ) ) {\n\t\t\t\tformat = lastFormat;\n\t\t\t} else {\n\t\t\t\tformat = newFormat;\n\t\t\t}\n\t\t}\n\n\t\tconst value = createFromElement( {\n\t\t\telement: node,\n\t\t\trange,\n\t\t\tremoveNode,\n\t\t\tunwrapNode,\n\t\t\tfilterString,\n\t\t\tremoveAttribute,\n\t\t} );\n\n\t\tconst text = value.text;\n\t\tconst start = accumulator.text.length;\n\n\t\taccumulateSelection( accumulator, node, range, value );\n\n\t\t// Don't apply the element as formatting if it has no content.\n\t\tif ( isEmpty( value ) && format && ! format.attributes ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst { formats } = accumulator;\n\n\t\tif ( format && format.attributes && text.length === 0 ) {\n\t\t\tformat.object = true;\n\t\t\t// Object replacement character.\n\t\t\taccumulator.text += '\\ufffc';\n\n\t\t\tif ( formats[ start ] ) {\n\t\t\t\tformats[ start ].unshift( format );\n\t\t\t} else {\n\t\t\t\tformats[ start ] = [ format ];\n\t\t\t}\n\t\t} else {\n\t\t\taccumulator.text += text;\n\n\t\t\tlet i = value.formats.length;\n\n\t\t\t// Optimise for speed.\n\t\t\twhile ( i-- ) {\n\t\t\t\tconst formatIndex = start + i;\n\n\t\t\t\tif ( format ) {\n\t\t\t\t\tif ( formats[ formatIndex ] ) {\n\t\t\t\t\t\tformats[ formatIndex ].push( format );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tformats[ formatIndex ] = [ format ];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( value.formats[ i ] ) {\n\t\t\t\t\tif ( formats[ formatIndex ] ) {\n\t\t\t\t\t\tformats[ formatIndex ].push( ...value.formats[ i ] );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tformats[ formatIndex ] = value.formats[ i ];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn accumulator;\n}\n\n/**\n * Creates a rich text value from a DOM element and range that should be\n * multiline.\n *\n * @param {Object}    $1                 Named argements.\n * @param {?Element}  $1.element         Element to create value from.\n * @param {?Range}    $1.range           Range to create value from.\n * @param {?string}   $1.multilineTag    Multiline tag if the structure is\n *                                       multiline.\n * @param {?Function} $1.removeNode      Function to declare whether the given\n *                                       node should be removed.\n * @param {?Function} $1.unwrapNode      Function to declare whether the given\n *                                       node should be unwrapped.\n * @param {?Function} $1.filterString    Function to filter the given string.\n * @param {?Function} $1.removeAttribute Wether to remove an attribute based on\n *                                       the name.\n *\n * @return {Object} A rich text value.\n */\nfunction createFromMultilineElement( {\n\telement,\n\trange,\n\tmultilineTag,\n\tremoveNode,\n\tunwrapNode,\n\tfilterString,\n\tremoveAttribute,\n} ) {\n\tconst accumulator = createEmptyValue();\n\n\tif ( ! element || ! element.hasChildNodes() ) {\n\t\treturn accumulator;\n\t}\n\n\tconst length = element.children.length;\n\n\t// Optimise for speed.\n\tfor ( let index = 0; index < length; index++ ) {\n\t\tconst node = element.children[ index ];\n\n\t\tif ( node.nodeName.toLowerCase() !== multilineTag ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst value = createFromElement( {\n\t\t\telement: node,\n\t\t\trange,\n\t\t\tmultilineTag,\n\t\t\tremoveNode,\n\t\t\tunwrapNode,\n\t\t\tfilterString,\n\t\t\tremoveAttribute,\n\t\t} );\n\n\t\t// Multiline value text should be separated by a double line break.\n\t\tif ( index !== 0 ) {\n\t\t\taccumulator.formats = accumulator.formats.concat( [ , ] );\n\t\t\taccumulator.text += '\\u2028';\n\t\t}\n\n\t\taccumulateSelection( accumulator, node, range, value );\n\n\t\taccumulator.formats = accumulator.formats.concat( value.formats );\n\t\taccumulator.text += value.text;\n\t}\n\n\treturn accumulator;\n}\n\n/**\n * Gets the attributes of an element in object shape.\n *\n * @param {Object}    $1                 Named argements.\n * @param {Element}   $1.element         Element to get attributes from.\n * @param {?Function} $1.removeAttribute Wether to remove an attribute based on\n *                                       the name.\n *\n * @return {?Object} Attribute object or `undefined` if the element has no\n *                   attributes.\n */\nfunction getAttributes( {\n\telement,\n\tremoveAttribute,\n} ) {\n\tif ( ! element.hasAttributes() ) {\n\t\treturn;\n\t}\n\n\tconst length = element.attributes.length;\n\tlet accumulator;\n\n\t// Optimise for speed.\n\tfor ( let i = 0; i < length; i++ ) {\n\t\tconst { name, value } = element.attributes[ i ];\n\n\t\tif ( removeAttribute && removeAttribute( name ) ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\taccumulator = accumulator || {};\n\t\taccumulator[ name ] = value;\n\t}\n\n\treturn accumulator;\n}\n","/**\n * External dependencies\n */\n\nimport { find } from 'lodash';\n\n/**\n * Gets the format object by type at the start of the selection. This can be\n * used to get e.g. the URL of a link format at the current selection, but also\n * to check if a format is active at the selection. Returns undefined if there\n * is no format at the selection.\n *\n * @param {Object} value      Value to inspect.\n * @param {string} formatType Format type to look for.\n *\n * @return {?Object} Active format object of the specified type, or undefined.\n */\nexport function getActiveFormat( { formats, start }, formatType ) {\n\tif ( start === undefined ) {\n\t\treturn;\n\t}\n\n\treturn find( formats[ start ], { type: formatType } );\n}\n","/**\n * Get the textual content of a Rich Text value. This is similar to\n * `Element.textContent`.\n *\n * @param {Object} value Value to use.\n *\n * @return {string} The text content.\n */\nexport function getTextContent( { text } ) {\n\treturn text;\n}\n","export { applyFormat } from './apply-format';\nexport { concat } from './concat';\nexport { create } from './create';\nexport { getActiveFormat } from './get-active-format';\nexport { getTextContent } from './get-text-content';\nexport { isCollapsed } from './is-collapsed';\nexport { isEmpty, isEmptyLine } from './is-empty';\nexport { join } from './join';\nexport { removeFormat } from './remove-format';\nexport { remove } from './remove';\nexport { replace } from './replace';\nexport { insert } from './insert';\nexport { slice } from './slice';\nexport { split } from './split';\nexport { apply, toDom as unstableToDom } from './to-dom';\nexport { toHTMLString } from './to-html-string';\n","/**\n * Internal dependencies\n */\n\nimport { create } from './create';\nimport { normaliseFormats } from './normalise-formats';\n\n/**\n * Insert a Rich Text value, an HTML string, or a plain text string, into a\n * Rich Text value at the given `startIndex`. Any content between `startIndex`\n * and `endIndex` will be removed. Indices are retrieved from the selection if\n * none are provided.\n *\n * @param {Object} value         Value to modify.\n * @param {string} valueToInsert Value to insert.\n * @param {number} startIndex    Start index.\n * @param {number} endIndex      End index.\n *\n * @return {Object} A new value with the value inserted.\n */\nexport function insert(\n\t{ formats, text, start, end },\n\tvalueToInsert,\n\tstartIndex = start,\n\tendIndex = end\n) {\n\tif ( typeof valueToInsert === 'string' ) {\n\t\tvalueToInsert = create( { text: valueToInsert } );\n\t}\n\n\tconst index = startIndex + valueToInsert.text.length;\n\n\treturn normaliseFormats( {\n\t\tformats: formats.slice( 0, startIndex ).concat( valueToInsert.formats, formats.slice( endIndex ) ),\n\t\ttext: text.slice( 0, startIndex ) + valueToInsert.text + text.slice( endIndex ),\n\t\tstart: index,\n\t\tend: index,\n\t} );\n}\n","/**\n * Check if the selection of a Rich Text value is collapsed or not. Collapsed\n * means that no characters are selected, but there is a caret present. If there\n * is no selection, `undefined` will be returned. This is similar to\n * `window.getSelection().isCollapsed()`.\n *\n * @param {Object} value The rich text value to check.\n *\n * @return {?boolean} True if the selection is collapsed, false if not,\n *                    undefined if there is no selection.\n */\nexport function isCollapsed( { start, end } ) {\n\tif ( start === undefined || end === undefined ) {\n\t\treturn;\n\t}\n\n\treturn start === end;\n}\n","/**\n * Check if a Rich Text value is Empty, meaning it contains no text or any\n * objects (such as images).\n *\n * @param {Object} value Value to use.\n *\n * @return {boolean} True if the value is empty, false if not.\n */\nexport function isEmpty( { text } ) {\n\treturn text.length === 0;\n}\n\n/**\n * Check if the current collapsed selection is on an empty line in case of a\n * multiline value.\n *\n * @param  {Object} value Value te check.\n *\n * @return {boolean} True if the line is empty, false if not.\n */\nexport function isEmptyLine( { text, start, end } ) {\n\tif ( start !== end ) {\n\t\treturn false;\n\t}\n\n\tif ( text.length === 0 ) {\n\t\treturn true;\n\t}\n\n\tif ( start === 0 && text.slice( 0, 1 ) === '\\u2028' ) {\n\t\treturn true;\n\t}\n\n\tif ( start === text.length && text.slice( -1 ) === '\\u2028' ) {\n\t\treturn true;\n\t}\n\n\treturn text.slice( start - 1, end + 1 ) === '\\u2028\\u2028';\n}\n","/**\n * Optimised equality check for format objects.\n *\n * @param {?Object} format1 Format to compare.\n * @param {?Object} format2 Format to compare.\n *\n * @return {boolean} True if formats are equal, false if not.\n */\nexport function isFormatEqual( format1, format2 ) {\n\t// Both not defined.\n\tif ( format1 === format2 ) {\n\t\treturn true;\n\t}\n\n\t// Either not defined.\n\tif ( ! format1 || ! format2 ) {\n\t\treturn false;\n\t}\n\n\tif ( format1.type !== format2.type ) {\n\t\treturn false;\n\t}\n\n\tconst attributes1 = format1.attributes;\n\tconst attributes2 = format2.attributes;\n\n\t// Both not defined.\n\tif ( attributes1 === attributes2 ) {\n\t\treturn true;\n\t}\n\n\t// Either not defined.\n\tif ( ! attributes1 || ! attributes2 ) {\n\t\treturn false;\n\t}\n\n\tconst keys1 = Object.keys( attributes1 );\n\tconst keys2 = Object.keys( attributes2 );\n\n\tif ( keys1.length !== keys2.length ) {\n\t\treturn false;\n\t}\n\n\tconst length = keys1.length;\n\n\t// Optimise for speed.\n\tfor ( let i = 0; i < length; i++ ) {\n\t\tconst name = keys1[ i ];\n\n\t\tif ( attributes1[ name ] !== attributes2[ name ] ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n","/**\n * Internal dependencies\n */\n\nimport { create } from './create';\nimport { normaliseFormats } from './normalise-formats';\n\n/**\n * Combine an array of Rich Text values into one, optionally separated by\n * `separator`, which can be a Rich Text value, HTML string, or plain text\n * string. This is similar to `Array.prototype.join`.\n *\n * @param {Array}         values    An array of values to join.\n * @param {string|Object} separator Separator string or value.\n *\n * @return {Object} A new combined value.\n */\nexport function join( values, separator = '' ) {\n\tif ( typeof separator === 'string' ) {\n\t\tseparator = create( { text: separator } );\n\t}\n\n\treturn normaliseFormats( values.reduce( ( accumlator, { formats, text } ) => ( {\n\t\ttext: accumlator.text + separator.text + text,\n\t\tformats: accumlator.formats.concat( separator.formats, formats ),\n\t} ) ) );\n}\n","/**\n * Internal dependencies\n */\n\nimport { isFormatEqual } from './is-format-equal';\n\n/**\n * Normalises formats: ensures subsequent equal formats have the same reference.\n *\n * @param  {Object} value Value to normalise formats of.\n *\n * @return {Object} New value with normalised formats.\n */\nexport function normaliseFormats( { formats, text, start, end } ) {\n\tconst newFormats = formats.slice( 0 );\n\n\tnewFormats.forEach( ( formatsAtIndex, index ) => {\n\t\tconst lastFormatsAtIndex = newFormats[ index - 1 ];\n\n\t\tif ( lastFormatsAtIndex ) {\n\t\t\tconst newFormatsAtIndex = formatsAtIndex.slice( 0 );\n\n\t\t\tnewFormatsAtIndex.forEach( ( format, formatIndex ) => {\n\t\t\t\tconst lastFormat = lastFormatsAtIndex[ formatIndex ];\n\n\t\t\t\tif ( isFormatEqual( format, lastFormat ) ) {\n\t\t\t\t\tnewFormatsAtIndex[ formatIndex ] = lastFormat;\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\tnewFormats[ index ] = newFormatsAtIndex;\n\t\t}\n\t} );\n\n\treturn { formats: newFormats, text, start, end };\n}\n","/**\n * External dependencies\n */\n\nimport { find } from 'lodash';\n\n/**\n * Internal dependencies\n */\n\nimport { normaliseFormats } from './normalise-formats';\n\n/**\n * Remove any format object from a Rich Text value by type from the given\n * `startIndex` to the given `endIndex`. Indices are retrieved from the\n * selection if none are provided.\n *\n * @param {Object} value      Value to modify.\n * @param {string} formatType Format type to remove.\n * @param {number} startIndex Start index.\n * @param {number} endIndex   End index.\n *\n * @return {Object} A new value with the format applied.\n */\nexport function removeFormat(\n\t{ formats, text, start, end },\n\tformatType,\n\tstartIndex = start,\n\tendIndex = end\n) {\n\tconst newFormats = formats.slice( 0 );\n\n\t// If the selection is collapsed, expand start and end to the edges of the\n\t// format.\n\tif ( startIndex === endIndex ) {\n\t\tconst format = find( newFormats[ startIndex ], { type: formatType } );\n\n\t\twhile ( find( newFormats[ startIndex ], format ) ) {\n\t\t\tfilterFormats( newFormats, startIndex, formatType );\n\t\t\tstartIndex--;\n\t\t}\n\n\t\tendIndex++;\n\n\t\twhile ( find( newFormats[ endIndex ], format ) ) {\n\t\t\tfilterFormats( newFormats, endIndex, formatType );\n\t\t\tendIndex++;\n\t\t}\n\t} else {\n\t\tfor ( let i = startIndex; i < endIndex; i++ ) {\n\t\t\tif ( newFormats[ i ] ) {\n\t\t\t\tfilterFormats( newFormats, i, formatType );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn normaliseFormats( { formats: newFormats, text, start, end } );\n}\n\nfunction filterFormats( formats, index, formatType ) {\n\tconst newFormats = formats[ index ].filter( ( { type } ) => type !== formatType );\n\n\tif ( newFormats.length ) {\n\t\tformats[ index ] = newFormats;\n\t} else {\n\t\tdelete formats[ index ];\n\t}\n}\n","/**\n * Internal dependencies\n */\n\nimport { insert } from './insert';\nimport { create } from './create';\n\n/**\n * Remove content from a Rich Text value between the given `startIndex` and\n * `endIndex`. Indices are retrieved from the selection if none are provided.\n *\n * @param {Object} value      Value to modify.\n * @param {number} startIndex Start index.\n * @param {number} endIndex   End index.\n *\n * @return {Object} A new value with the content removed.\n */\nexport function remove( value, startIndex, endIndex ) {\n\treturn insert( value, create(), startIndex, endIndex );\n}\n","/**\n * Internal dependencies\n */\n\nimport { normaliseFormats } from './normalise-formats';\n\n/**\n * Search a Rich Text value and replace the match(es) with `replacement`. This\n * is similar to `String.prototype.replace`.\n *\n * @param {Object}         value        The value to modify.\n * @param {RegExp|string}  pattern      A RegExp object or literal. Can also be\n *                                      a string. It is treated as a verbatim\n *                                      string and is not interpreted as a\n *                                      regular expression. Only the first\n *                                      occurrence will be replaced.\n * @param {Function|string} replacement The match or matches are replaced with\n *                                      the specified or the value returned by\n *                                      the specified function.\n *\n * @return {Object} A new value with replacements applied.\n */\nexport function replace( { formats, text, start, end }, pattern, replacement ) {\n\ttext = text.replace( pattern, ( match, ...rest ) => {\n\t\tconst offset = rest[ rest.length - 2 ];\n\t\tlet newText = replacement;\n\t\tlet newFormats;\n\n\t\tif ( typeof newText === 'function' ) {\n\t\t\tnewText = replacement( match, ...rest );\n\t\t}\n\n\t\tif ( typeof newText === 'object' ) {\n\t\t\tnewFormats = newText.formats;\n\t\t\tnewText = newText.text;\n\t\t} else {\n\t\t\tnewFormats = Array( newText.length );\n\n\t\t\tif ( formats[ offset ] ) {\n\t\t\t\tnewFormats = newFormats.fill( formats[ offset ] );\n\t\t\t}\n\t\t}\n\n\t\tformats = formats.slice( 0, offset ).concat( newFormats, formats.slice( offset + match.length ) );\n\n\t\tif ( start ) {\n\t\t\tstart = end = offset + newText.length;\n\t\t}\n\n\t\treturn newText;\n\t} );\n\n\treturn normaliseFormats( { formats, text, start, end } );\n}\n","/**\n * Slice a Rich Text value from `startIndex` to `endIndex`. Indices are\n * retrieved from the selection if none are provided. This is similar to\n * `String.prototype.slice`.\n *\n * @param {Object} value       Value to modify.\n * @param {number} startIndex  Start index.\n * @param {number} endIndex    End index.\n *\n * @return {Object} A new extracted value.\n */\nexport function slice(\n\t{ formats, text, start, end },\n\tstartIndex = start,\n\tendIndex = end\n) {\n\tif ( startIndex === undefined || endIndex === undefined ) {\n\t\treturn { formats, text };\n\t}\n\n\treturn {\n\t\tformats: formats.slice( startIndex, endIndex ),\n\t\ttext: text.slice( startIndex, endIndex ),\n\t};\n}\n","/**\n * Internal dependencies\n */\n\nimport { replace } from './replace';\n\n/**\n * Split a Rich Text value in two at the given `startIndex` and `endIndex`, or\n * split at the given separator. This is similar to `String.prototype.split`.\n * Indices are retrieved from the selection if none are provided.\n *\n * @param {Object}        value   Value to modify.\n * @param {number|string} string  Start index, or string at which to split.\n * @param {number}        end     End index.\n *\n * @return {Array} An array of new values.\n */\nexport function split( { formats, text, start, end }, string ) {\n\tif ( typeof string !== 'string' ) {\n\t\treturn splitAtSelection( ...arguments );\n\t}\n\n\tlet nextStart = 0;\n\n\treturn text.split( string ).map( ( substring ) => {\n\t\tconst startIndex = nextStart;\n\t\tconst value = {\n\t\t\tformats: formats.slice( startIndex, startIndex + substring.length ),\n\t\t\ttext: substring,\n\t\t};\n\n\t\tnextStart += string.length + substring.length;\n\n\t\tif ( start !== undefined && end !== undefined ) {\n\t\t\tif ( start >= startIndex && start < nextStart ) {\n\t\t\t\tvalue.start = start - startIndex;\n\t\t\t} else if ( start < startIndex && end > startIndex ) {\n\t\t\t\tvalue.start = 0;\n\t\t\t}\n\n\t\t\tif ( end >= startIndex && end < nextStart ) {\n\t\t\t\tvalue.end = end - startIndex;\n\t\t\t} else if ( start < nextStart && end > nextStart ) {\n\t\t\t\tvalue.end = substring.length;\n\t\t\t}\n\t\t}\n\n\t\treturn value;\n\t} );\n}\n\nfunction splitAtSelection(\n\t{ formats, text, start, end },\n\tstartIndex = start,\n\tendIndex = end\n) {\n\tconst before = {\n\t\tformats: formats.slice( 0, startIndex ),\n\t\ttext: text.slice( 0, startIndex ),\n\t};\n\tconst after = {\n\t\tformats: formats.slice( endIndex ),\n\t\ttext: text.slice( endIndex ),\n\t\tstart: 0,\n\t\tend: 0,\n\t};\n\n\treturn [\n\t\t// Ensure newlines are trimmed.\n\t\treplace( before, /\\u2028+$/, '' ),\n\t\treplace( after, /^\\u2028+/, '' ),\n\t];\n}\n","/**\n * Internal dependencies\n */\n\nimport { toTree } from './to-tree';\n\n/**\n * Browser dependencies\n */\n\nconst { TEXT_NODE, ELEMENT_NODE } = window.Node;\n\n/**\n * Creates a path as an array of indices from the given root node to the given\n * node.\n *\n * @param {Node}        node     Node to find the path of.\n * @param {HTMLElement} rootNode Root node to find the path from.\n * @param {Array}       path     Initial path to build on.\n *\n * @return {Array} The path from the root node to the node.\n */\nfunction createPathToNode( node, rootNode, path ) {\n\tconst parentNode = node.parentNode;\n\tlet i = 0;\n\n\twhile ( ( node = node.previousSibling ) ) {\n\t\ti++;\n\t}\n\n\tpath = [ i, ...path ];\n\n\tif ( parentNode !== rootNode ) {\n\t\tpath = createPathToNode( parentNode, rootNode, path );\n\t}\n\n\treturn path;\n}\n\n/**\n * Gets a node given a path (array of indices) from the given node.\n *\n * @param {HTMLElement} node Root node to find the wanted node in.\n * @param {Array}       path Path (indices) to the wanted node.\n *\n * @return {Object} Object with the found node and the remaining offset (if any).\n */\nfunction getNodeByPath( node, path ) {\n\tpath = [ ...path ];\n\n\twhile ( node && path.length > 1 ) {\n\t\tnode = node.childNodes[ path.shift() ];\n\t}\n\n\treturn {\n\t\tnode,\n\t\toffset: path[ 0 ],\n\t};\n}\n\nfunction createEmpty( type ) {\n\tconst { body } = document.implementation.createHTMLDocument( '' );\n\n\tif ( type ) {\n\t\treturn body.appendChild( body.ownerDocument.createElement( type ) );\n\t}\n\n\treturn body;\n}\n\nfunction append( element, child ) {\n\tif ( typeof child === 'string' ) {\n\t\tchild = element.ownerDocument.createTextNode( child );\n\t}\n\n\tconst { type, attributes } = child;\n\n\tif ( type ) {\n\t\tchild = element.ownerDocument.createElement( type );\n\n\t\tfor ( const key in attributes ) {\n\t\t\tchild.setAttribute( key, attributes[ key ] );\n\t\t}\n\t}\n\n\treturn element.appendChild( child );\n}\n\nfunction appendText( node, text ) {\n\tnode.appendData( text );\n}\n\nfunction getLastChild( { lastChild } ) {\n\treturn lastChild;\n}\n\nfunction getParent( { parentNode } ) {\n\treturn parentNode;\n}\n\nfunction isText( { nodeType } ) {\n\treturn nodeType === TEXT_NODE;\n}\n\nfunction getText( { nodeValue } ) {\n\treturn nodeValue;\n}\n\nfunction remove( node ) {\n\treturn node.parentNode.removeChild( node );\n}\n\nexport function toDom( value, multilineTag ) {\n\tlet startPath = [];\n\tlet endPath = [];\n\n\tconst tree = toTree( value, multilineTag, {\n\t\tcreateEmpty,\n\t\tappend,\n\t\tgetLastChild,\n\t\tgetParent,\n\t\tisText,\n\t\tgetText,\n\t\tremove,\n\t\tappendText,\n\t\tonStartIndex( body, pointer, multilineIndex ) {\n\t\t\tstartPath = createPathToNode( pointer, body, [ pointer.nodeValue.length ] );\n\n\t\t\tif ( multilineIndex !== undefined ) {\n\t\t\t\tstartPath = [ multilineIndex, ...startPath ];\n\t\t\t}\n\t\t},\n\t\tonEndIndex( body, pointer, multilineIndex ) {\n\t\t\tendPath = createPathToNode( pointer, body, [ pointer.nodeValue.length ] );\n\n\t\t\tif ( multilineIndex !== undefined ) {\n\t\t\t\tendPath = [ multilineIndex, ...endPath ];\n\t\t\t}\n\t\t},\n\t\tonEmpty( body ) {\n\t\t\tconst br = body.ownerDocument.createElement( 'br' );\n\t\t\tbr.setAttribute( 'data-mce-bogus', '1' );\n\t\t\tbody.appendChild( br );\n\t\t},\n\t} );\n\n\treturn {\n\t\tbody: tree,\n\t\tselection: { startPath, endPath },\n\t};\n}\n\n/**\n * Create an `Element` tree from a Rich Text value and applies the difference to\n * the `Element` tree contained by `current`. If a `multilineTag` is provided,\n * text separated by two new lines will be wrapped in an `Element` of that type.\n *\n * @param {Object}      value        Value to apply.\n * @param {HTMLElement} current      The live root node to apply the element\n *                                   tree to.\n * @param {string}      multilineTag Multiline tag.\n */\nexport function apply( value, current, multilineTag ) {\n\t// Construct a new element tree in memory.\n\tconst { body, selection } = toDom( value, multilineTag );\n\n\tapplyValue( body, current );\n\n\tif ( value.start !== undefined ) {\n\t\tapplySelection( selection, current );\n\t}\n}\n\nexport function applyValue( future, current ) {\n\tlet i = 0;\n\n\twhile ( future.firstChild ) {\n\t\tconst currentChild = current.childNodes[ i ];\n\t\tconst futureNodeType = future.firstChild.nodeType;\n\n\t\tif ( ! currentChild ) {\n\t\t\tcurrent.appendChild( future.firstChild );\n\t\t} else if (\n\t\t\tfutureNodeType !== currentChild.nodeType ||\n\t\t\tfutureNodeType !== TEXT_NODE ||\n\t\t\tfuture.firstChild.nodeValue !== currentChild.nodeValue\n\t\t) {\n\t\t\tcurrent.replaceChild( future.firstChild, currentChild );\n\t\t} else {\n\t\t\tfuture.removeChild( future.firstChild );\n\t\t}\n\n\t\ti++;\n\t}\n\n\twhile ( current.childNodes[ i ] ) {\n\t\tcurrent.removeChild( current.childNodes[ i ] );\n\t}\n}\n\nexport function applySelection( selection, current ) {\n\tconst { node: startContainer, offset: startOffset } = getNodeByPath( current, selection.startPath );\n\tconst { node: endContainer, offset: endOffset } = getNodeByPath( current, selection.endPath );\n\n\tconst windowSelection = window.getSelection();\n\tconst range = current.ownerDocument.createRange();\n\tconst collapsed = startContainer === endContainer && startOffset === endOffset;\n\n\tif (\n\t\tcollapsed &&\n\t\tstartOffset === 0 &&\n\t\tstartContainer.previousSibling &&\n\t\tstartContainer.previousSibling.nodeType === ELEMENT_NODE &&\n\t\tstartContainer.previousSibling.nodeName !== 'BR'\n\t) {\n\t\tstartContainer.insertData( 0, '\\uFEFF' );\n\t\trange.setStart( startContainer, 1 );\n\t\trange.setEnd( endContainer, 1 );\n\t} else if (\n\t\tcollapsed &&\n\t\tstartOffset === 0 &&\n\t\tstartContainer === TEXT_NODE &&\n\t\tstartContainer.nodeValue.length === 0\n\t) {\n\t\tstartContainer.insertData( 0, '\\uFEFF' );\n\t\trange.setStart( startContainer, 1 );\n\t\trange.setEnd( endContainer, 1 );\n\t} else {\n\t\trange.setStart( startContainer, startOffset );\n\t\trange.setEnd( endContainer, endOffset );\n\t}\n\n\twindowSelection.removeAllRanges();\n\twindowSelection.addRange( range );\n}\n","/**\n * Internal dependencies\n */\n\nimport {\n\tescapeHTML,\n\tescapeAttribute,\n\tisValidAttributeName,\n} from '@wordpress/escape-html';\n\n/**\n * Internal dependencies\n */\n\nimport { toTree } from './to-tree';\n\n/**\n * Create an HTML string from a Rich Text value. If a `multilineTag` is\n * provided, text separated by two new lines will be wrapped in it.\n *\n * @param {Object} value        Rich text value.\n * @param {string} multilineTag Multiline tag.\n *\n * @return {string} HTML string.\n */\nexport function toHTMLString( value, multilineTag ) {\n\tconst tree = toTree( value, multilineTag, {\n\t\tcreateEmpty,\n\t\tappend,\n\t\tgetLastChild,\n\t\tgetParent,\n\t\tisText,\n\t\tgetText,\n\t\tremove,\n\t\tappendText,\n\t} );\n\n\treturn createChildrenHTML( tree.children );\n}\n\nfunction createEmpty( type ) {\n\treturn { type };\n}\n\nfunction getLastChild( { children } ) {\n\treturn children && children[ children.length - 1 ];\n}\n\nfunction append( parent, object ) {\n\tif ( typeof object === 'string' ) {\n\t\tobject = { text: object };\n\t}\n\n\tobject.parent = parent;\n\tparent.children = parent.children || [];\n\tparent.children.push( object );\n\treturn object;\n}\n\nfunction appendText( object, text ) {\n\tobject.text += text;\n}\n\nfunction getParent( { parent } ) {\n\treturn parent;\n}\n\nfunction isText( { text } ) {\n\treturn typeof text === 'string';\n}\n\nfunction getText( { text } ) {\n\treturn text;\n}\n\nfunction remove( object ) {\n\tconst index = object.parent.children.indexOf( object );\n\n\tif ( index !== -1 ) {\n\t\tobject.parent.children.splice( index, 1 );\n\t}\n\n\treturn object;\n}\n\nfunction createElementHTML( { type, attributes, object, children } ) {\n\tlet attributeString = '';\n\n\tfor ( const key in attributes ) {\n\t\tif ( ! isValidAttributeName( key ) ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tattributeString += ` ${ key }=\"${ escapeAttribute( attributes[ key ] ) }\"`;\n\t}\n\n\tif ( object ) {\n\t\treturn `<${ type }${ attributeString }>`;\n\t}\n\n\treturn `<${ type }${ attributeString }>${ createChildrenHTML( children ) }</${ type }>`;\n}\n\nfunction createChildrenHTML( children = [] ) {\n\treturn children.map( ( child ) => {\n\t\treturn child.text === undefined ? createElementHTML( child ) : escapeHTML( child.text );\n\t} ).join( '' );\n}\n","/**\n * Internal dependencies\n */\n\nimport { split } from './split';\n\nexport function toTree( value, multilineTag, settings ) {\n\tif ( multilineTag ) {\n\t\tconst { createEmpty, append } = settings;\n\t\tconst tree = createEmpty();\n\n\t\tsplit( value, '\\u2028' ).forEach( ( piece, index ) => {\n\t\t\tappend( tree, toTree( piece, null, {\n\t\t\t\t...settings,\n\t\t\t\ttag: multilineTag,\n\t\t\t\tmultilineIndex: index,\n\t\t\t} ) );\n\t\t} );\n\n\t\treturn tree;\n\t}\n\n\tconst {\n\t\ttag,\n\t\tmultilineIndex,\n\t\tcreateEmpty,\n\t\tappend,\n\t\tgetLastChild,\n\t\tgetParent,\n\t\tisText,\n\t\tgetText,\n\t\tremove,\n\t\tappendText,\n\t\tonStartIndex,\n\t\tonEndIndex,\n\t\tonEmpty,\n\t} = settings;\n\tconst { formats, text, start, end } = value;\n\tconst formatsLength = formats.length + 1;\n\tconst tree = createEmpty( tag );\n\n\tappend( tree, '' );\n\n\tfor ( let i = 0; i < formatsLength; i++ ) {\n\t\tconst character = text.charAt( i );\n\t\tconst characterFormats = formats[ i ];\n\t\tconst lastCharacterFormats = formats[ i - 1 ];\n\n\t\tlet pointer = getLastChild( tree );\n\n\t\tif ( characterFormats ) {\n\t\t\tcharacterFormats.forEach( ( format, formatIndex ) => {\n\t\t\t\tif (\n\t\t\t\t\tpointer &&\n\t\t\t\t\tlastCharacterFormats &&\n\t\t\t\t\tformat === lastCharacterFormats[ formatIndex ]\n\t\t\t\t) {\n\t\t\t\t\tpointer = getLastChild( pointer );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst { type, attributes, object } = format;\n\t\t\t\tconst parent = getParent( pointer );\n\t\t\t\tconst newNode = append( parent, { type, attributes, object } );\n\n\t\t\t\tif ( isText( pointer ) && getText( pointer ).length === 0 ) {\n\t\t\t\t\tremove( pointer );\n\t\t\t\t}\n\n\t\t\t\tpointer = append( object ? parent : newNode, '' );\n\t\t\t} );\n\t\t}\n\n\t\t// If there is selection at 0, handle it before characters are inserted.\n\n\t\tif ( onStartIndex && start === 0 && i === 0 ) {\n\t\t\tonStartIndex( tree, pointer, multilineIndex );\n\t\t}\n\n\t\tif ( onEndIndex && end === 0 && i === 0 ) {\n\t\t\tonEndIndex( tree, pointer, multilineIndex );\n\t\t}\n\n\t\tif ( character !== '\\ufffc' ) {\n\t\t\tif ( character === '\\n' ) {\n\t\t\t\tpointer = append( getParent( pointer ), { type: 'br', object: true } );\n\t\t\t\t// Ensure pointer is text node.\n\t\t\t\tpointer = append( getParent( pointer ), '' );\n\t\t\t} else if ( ! isText( pointer ) ) {\n\t\t\t\tpointer = append( getParent( pointer ), character );\n\t\t\t} else {\n\t\t\t\tappendText( pointer, character );\n\t\t\t}\n\t\t}\n\n\t\tif ( onStartIndex && start === i + 1 ) {\n\t\t\tonStartIndex( tree, pointer, multilineIndex );\n\t\t}\n\n\t\tif ( onEndIndex && end === i + 1 ) {\n\t\t\tonEndIndex( tree, pointer, multilineIndex );\n\t\t}\n\t}\n\n\tif ( onEmpty && text.length === 0 ) {\n\t\tonEmpty( tree );\n\t}\n\n\treturn tree;\n}\n","(function() { module.exports = this[\"wp\"][\"escapeHtml\"]; }());","(function() { module.exports = this[\"lodash\"]; }());"],"sourceRoot":""}