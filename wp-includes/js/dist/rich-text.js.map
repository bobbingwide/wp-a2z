{"version":3,"sources":["webpack://wp.[name]/webpack/bootstrap","webpack://wp.[name]/./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","webpack://wp.[name]/./node_modules/@babel/runtime/helpers/esm/defineProperty.js","webpack://wp.[name]/./node_modules/@babel/runtime/helpers/esm/iterableToArray.js","webpack://wp.[name]/./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","webpack://wp.[name]/./node_modules/@babel/runtime/helpers/esm/objectSpread.js","webpack://wp.[name]/./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","webpack://wp.[name]/./node_modules/@babel/runtime/helpers/esm/typeof.js","webpack://wp.[name]//Users/pento/Projects/gutenberg/packages/rich-text/src/apply-format.js","webpack://wp.[name]//Users/pento/Projects/gutenberg/packages/rich-text/src/concat.js","webpack://wp.[name]//Users/pento/Projects/gutenberg/packages/rich-text/src/create-element.js","webpack://wp.[name]//Users/pento/Projects/gutenberg/packages/rich-text/src/create.js","webpack://wp.[name]//Users/pento/Projects/gutenberg/packages/rich-text/src/get-active-format.js","webpack://wp.[name]//Users/pento/Projects/gutenberg/packages/rich-text/src/get-format-type.js","webpack://wp.[name]//Users/pento/Projects/gutenberg/packages/rich-text/src/get-format-types.js","webpack://wp.[name]//Users/pento/Projects/gutenberg/packages/rich-text/src/get-text-content.js","webpack://wp.[name]//Users/pento/Projects/gutenberg/packages/rich-text/src/index.js","webpack://wp.[name]//Users/pento/Projects/gutenberg/packages/rich-text/src/insert-object.js","webpack://wp.[name]//Users/pento/Projects/gutenberg/packages/rich-text/src/insert.js","webpack://wp.[name]//Users/pento/Projects/gutenberg/packages/rich-text/src/is-collapsed.js","webpack://wp.[name]//Users/pento/Projects/gutenberg/packages/rich-text/src/is-empty.js","webpack://wp.[name]//Users/pento/Projects/gutenberg/packages/rich-text/src/is-format-equal.js","webpack://wp.[name]//Users/pento/Projects/gutenberg/packages/rich-text/src/join.js","webpack://wp.[name]//Users/pento/Projects/gutenberg/packages/rich-text/src/normalise-formats.js","webpack://wp.[name]//Users/pento/Projects/gutenberg/packages/rich-text/src/register-format-type.js","webpack://wp.[name]//Users/pento/Projects/gutenberg/packages/rich-text/src/remove-format.js","webpack://wp.[name]//Users/pento/Projects/gutenberg/packages/rich-text/src/remove.js","webpack://wp.[name]//Users/pento/Projects/gutenberg/packages/rich-text/src/replace.js","webpack://wp.[name]//Users/pento/Projects/gutenberg/packages/rich-text/src/slice.js","webpack://wp.[name]//Users/pento/Projects/gutenberg/packages/rich-text/src/special-characters.js","webpack://wp.[name]//Users/pento/Projects/gutenberg/packages/rich-text/src/split.js","webpack://wp.[name]//Users/pento/Projects/gutenberg/packages/rich-text/src/store/actions.js","webpack://wp.[name]//Users/pento/Projects/gutenberg/packages/rich-text/src/store/index.js","webpack://wp.[name]//Users/pento/Projects/gutenberg/packages/rich-text/src/store/reducer.js","webpack://wp.[name]//Users/pento/Projects/gutenberg/packages/rich-text/src/store/selectors.js","webpack://wp.[name]//Users/pento/Projects/gutenberg/packages/rich-text/src/to-dom.js","webpack://wp.[name]//Users/pento/Projects/gutenberg/packages/rich-text/src/to-html-string.js","webpack://wp.[name]//Users/pento/Projects/gutenberg/packages/rich-text/src/to-tree.js","webpack://wp.[name]//Users/pento/Projects/gutenberg/packages/rich-text/src/toggle-format.js","webpack://wp.[name]//Users/pento/Projects/gutenberg/packages/rich-text/src/unregister-format-type.js","webpack://wp.[name]/./node_modules/rememo/es/rememo.js","webpack://wp.[name]/external {\"this\":[\"wp\",\"data\"]}","webpack://wp.[name]/external {\"this\":[\"wp\",\"escapeHtml\"]}","webpack://wp.[name]/external \"lodash\""],"names":["applyFormat","format","formats","text","start","end","startIndex","endIndex","newFormats","slice","startFormat","find","type","applyFormats","previousFormat","hasType","insert","reject","ZERO_WIDTH_NO_BREAK_SPACE","index","normaliseFormats","newFormatsAtIndex","filter","push","concat","values","reduce","accumlator","createElement","html","implementation","createHTMLDocument","body","innerHTML","window","Node","TEXT_NODE","ELEMENT_NODE","createEmptyValue","simpleFindKey","object","value","key","toFormat","attributes","formatType","getFormatTypes","match","tagName","name","registeredAttributes","unregisteredAttributes","create","element","range","multilineTag","removeNode","unwrapNode","filterString","removeAttribute","length","Array","document","createFromElement","createFromMultilineElement","accumulateSelection","accumulator","node","parentNode","startContainer","startOffset","endContainer","endOffset","currentLength","undefined","childNodes","filterRange","nodeValue","hasChildNodes","filterStringComplete","string","replace","nodeType","nodeName","lastFormats","lastFormat","newFormat","toLowerCase","getAttributes","isFormatEqual","isEmpty","unshift","i","formatIndex","children","hasAttributes","getActiveFormat","getFormatType","select","getTextContent","OBJECT_REPLACEMENT_CHARACTER","insertObject","formatToInsert","valueToInsert","isCollapsed","isEmptyLine","format1","format2","attributes1","attributes2","keys1","Object","keys","keys2","join","separator","forEach","formatsAtIndex","lastFormatsAtIndex","registerFormatType","settings","console","error","test","isFunction","edit","title","keywords","dispatch","addFormatTypes","removeFormat","filterFormats","remove","pattern","replacement","rest","offset","newText","fill","split","splitAtSelection","arguments","nextStart","map","substring","before","after","formatTypes","castArray","removeFormatTypes","names","registerStore","reducer","selectors","actions","state","action","keyBy","omit","combineReducers","createSelector","createPathToNode","rootNode","path","previousSibling","getNodeByPath","shift","createEmpty","appendChild","ownerDocument","append","child","createTextNode","setAttribute","appendText","appendData","getLastChild","lastChild","getParent","isText","getText","removeChild","toDom","startPath","endPath","tree","toTree","onStartIndex","pointer","multilineIndex","onEndIndex","onEmpty","br","selection","apply","current","applyValue","applySelection","future","firstChild","currentChild","futureNodeType","replaceChild","windowSelection","getSelection","createRange","collapsed","insertData","setStart","setEnd","removeAllRanges","addRange","toHTMLString","createChildrenHTML","parent","indexOf","splice","createElementHTML","attributeString","isValidAttributeName","escapeAttribute","escapeHTML","fromFormat","elementAttributes","piece","tag","formatsLength","character","charAt","characterFormats","lastCharacterFormats","newNode","toggleFormat","unregisterFormatType","oldFormat"],"mappings":"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,CAAE,gBAAF,CAAR,CAA6BqB,iBAA7B,CAAgDpG,IAAhD;AAEA,SAAOyL,SAAP;AACA;;;;;;;;;;;;;AC1BD;AAAa;;AAEb;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,WAAW,EAAE;AACb;AACA,YAAY,MAAM;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,cAAc;AACnC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACe;AACf;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA,cAAc,uBAAuB;AACrC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,KAAK;AACjB;AACA,aAAa,EAAE;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,SAAS;AACvB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;ACjRD,aAAa,qCAAqC,EAAE,I;;;;;;;;;;;ACApD,aAAa,2CAA2C,EAAE,I;;;;;;;;;;;ACA1D,aAAa,iCAAiC,EAAE,I","file":"rich-text.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./node_modules/@wordpress/rich-text/build-module/index.js\");\n","export default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","export default function _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}","import defineProperty from \"./defineProperty\";\nexport default function _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}","import arrayWithoutHoles from \"./arrayWithoutHoles\";\nimport iterableToArray from \"./iterableToArray\";\nimport nonIterableSpread from \"./nonIterableSpread\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();\n}","function _typeof2(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof2(obj); }\n\nexport default function _typeof(obj) {\n  if (typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return _typeof2(obj);\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n    };\n  }\n\n  return _typeof(obj);\n}","/**\n * External dependencies\n */\n\nimport { find, reject } from 'lodash';\n\n/**\n * Internal dependencies\n */\n\nimport { normaliseFormats } from './normalise-formats';\nimport { insert } from './insert';\nimport { ZERO_WIDTH_NO_BREAK_SPACE } from './special-characters';\n\n/**\n * Apply a format object to a Rich Text value from the given `startIndex` to the\n * given `endIndex`. Indices are retrieved from the selection if none are\n * provided.\n *\n * @param {Object} value      Value to modify.\n * @param {Object} format     Format to apply.\n * @param {number} startIndex Start index.\n * @param {number} endIndex   End index.\n *\n * @return {Object} A new value with the format applied.\n */\nexport function applyFormat(\n\t{ formats, text, start, end },\n\tformat,\n\tstartIndex = start,\n\tendIndex = end\n) {\n\tconst newFormats = formats.slice( 0 );\n\n\t// The selection is collpased.\n\tif ( startIndex === endIndex ) {\n\t\tconst startFormat = find( newFormats[ startIndex ], { type: format.type } );\n\n\t\t// If the caret is at a format of the same type, expand start and end to\n\t\t// the edges of the format. This is useful to apply new attributes.\n\t\tif ( startFormat ) {\n\t\t\twhile ( find( newFormats[ startIndex ], startFormat ) ) {\n\t\t\t\tapplyFormats( newFormats, startIndex, format );\n\t\t\t\tstartIndex--;\n\t\t\t}\n\n\t\t\tendIndex++;\n\n\t\t\twhile ( find( newFormats[ endIndex ], startFormat ) ) {\n\t\t\t\tapplyFormats( newFormats, endIndex, format );\n\t\t\t\tendIndex++;\n\t\t\t}\n\t\t// Otherwise, insert a placeholder with the format so new input appears\n\t\t// with the format applied.\n\t\t} else {\n\t\t\tconst previousFormat = newFormats[ startIndex - 1 ] || [];\n\t\t\tconst hasType = find( previousFormat, { type: format.type } );\n\n\t\t\treturn insert( { formats, text, start, end }, {\n\t\t\t\tformats: hasType ? [ reject( previousFormat, { type: format.type } ) ] : [ [ ...previousFormat, format ] ],\n\t\t\t\ttext: ZERO_WIDTH_NO_BREAK_SPACE,\n\t\t\t} );\n\t\t}\n\t} else {\n\t\tfor ( let index = startIndex; index < endIndex; index++ ) {\n\t\t\tapplyFormats( newFormats, index, format );\n\t\t}\n\t}\n\n\treturn normaliseFormats( { formats: newFormats, text, start, end } );\n}\n\nfunction applyFormats( formats, index, format ) {\n\tif ( formats[ index ] ) {\n\t\tconst newFormatsAtIndex = formats[ index ].filter( ( { type } ) => type !== format.type );\n\t\tnewFormatsAtIndex.push( format );\n\t\tformats[ index ] = newFormatsAtIndex;\n\t} else {\n\t\tformats[ index ] = [ format ];\n\t}\n}\n","/**\n * Internal dependencies\n */\n\nimport { normaliseFormats } from './normalise-formats';\n\n/**\n * Combine all Rich Text values into one. This is similar to\n * `String.prototype.concat`.\n *\n * @param {...[object]} values An array of all values to combine.\n *\n * @return {Object} A new value combining all given records.\n */\nexport function concat( ...values ) {\n\treturn normaliseFormats( values.reduce( ( accumlator, { formats, text } ) => ( {\n\t\ttext: accumlator.text + text,\n\t\tformats: accumlator.formats.concat( formats ),\n\t} ) ) );\n}\n","/**\n * Parse the given HTML into a body element.\n *\n * @param {HTMLDocument} document The HTML document to use to parse.\n * @param {string}       html     The HTML to parse.\n *\n * @return {HTMLBodyElement} Body element with parsed HTML.\n */\nexport function createElement( { implementation }, html ) {\n\tconst { body } = implementation.createHTMLDocument( '' );\n\tbody.innerHTML = html;\n\treturn body;\n}\n","/**\n * External dependencies\n */\n\nimport { find } from 'lodash';\n\n/**\n * Internal dependencies\n */\n\nimport { isEmpty } from './is-empty';\nimport { isFormatEqual } from './is-format-equal';\nimport { createElement } from './create-element';\nimport { getFormatTypes } from './get-format-types';\n\n/**\n * Browser dependencies\n */\n\nconst { TEXT_NODE, ELEMENT_NODE } = window.Node;\n\nfunction createEmptyValue() {\n\treturn { formats: [], text: '' };\n}\n\nfunction simpleFindKey( object, value ) {\n\tfor ( const key in object ) {\n\t\tif ( object[ key ] === value ) {\n\t\t\treturn key;\n\t\t}\n\t}\n}\n\nfunction toFormat( { type, attributes } ) {\n\tconst formatType = find( getFormatTypes(), ( { match } ) =>\n\t\ttype === match.tagName\n\t);\n\n\tif ( ! formatType ) {\n\t\treturn attributes ? { type, attributes } : { type };\n\t}\n\n\tif ( ! attributes ) {\n\t\treturn { type: formatType.name };\n\t}\n\n\tconst registeredAttributes = {};\n\tconst unregisteredAttributes = {};\n\n\tfor ( const name in attributes ) {\n\t\tconst key = simpleFindKey( formatType.attributes, name );\n\n\t\tif ( key ) {\n\t\t\tregisteredAttributes[ key ] = attributes[ name ];\n\t\t} else {\n\t\t\tunregisteredAttributes[ name ] = attributes[ name ];\n\t\t}\n\t}\n\n\treturn {\n\t\ttype: formatType.name,\n\t\tattributes: registeredAttributes,\n\t\tunregisteredAttributes,\n\t};\n}\n\n/**\n * Create a RichText value from an `Element` tree (DOM), an HTML string or a\n * plain text string, with optionally a `Range` object to set the selection. If\n * called without any input, an empty value will be created. If\n * `multilineTag` is provided, any content of direct children whose type matches\n * `multilineTag` will be separated by two newlines. The optional functions can\n * be used to filter out content.\n *\n * @param {?Object}   $1                 Optional named argements.\n * @param {?Element}  $1.element         Element to create value from.\n * @param {?string}   $1.text            Text to create value from.\n * @param {?string}   $1.html            HTML to create value from.\n * @param {?Range}    $1.range           Range to create value from.\n * @param {?string}   $1.multilineTag    Multiline tag if the structure is\n *                                       multiline.\n * @param {?Function} $1.removeNode      Function to declare whether the given\n *                                       node should be removed.\n * @param {?Function} $1.unwrapNode      Function to declare whether the given\n *                                       node should be unwrapped.\n * @param {?Function} $1.filterString    Function to filter the given string.\n * @param {?Function} $1.removeAttribute Wether to remove an attribute based on\n *                                       the name.\n *\n * @return {Object} A rich text value.\n */\nexport function create( {\n\telement,\n\ttext,\n\thtml,\n\trange,\n\tmultilineTag,\n\tremoveNode,\n\tunwrapNode,\n\tfilterString,\n\tremoveAttribute,\n} = {} ) {\n\tif ( typeof text === 'string' && text.length > 0 ) {\n\t\treturn {\n\t\t\tformats: Array( text.length ),\n\t\t\ttext: text,\n\t\t};\n\t}\n\n\tif ( typeof html === 'string' && html.length > 0 ) {\n\t\telement = createElement( document, html );\n\t}\n\n\tif ( typeof element !== 'object' ) {\n\t\treturn createEmptyValue();\n\t}\n\n\tif ( ! multilineTag ) {\n\t\treturn createFromElement( {\n\t\t\telement,\n\t\t\trange,\n\t\t\tremoveNode,\n\t\t\tunwrapNode,\n\t\t\tfilterString,\n\t\t\tremoveAttribute,\n\t\t} );\n\t}\n\n\treturn createFromMultilineElement( {\n\t\telement,\n\t\trange,\n\t\tmultilineTag,\n\t\tremoveNode,\n\t\tunwrapNode,\n\t\tfilterString,\n\t\tremoveAttribute,\n\t} );\n}\n\n/**\n * Helper to accumulate the value's selection start and end from the current\n * node and range.\n *\n * @param {Object} accumulator Object to accumulate into.\n * @param {Node}   node        Node to create value with.\n * @param {Range}  range       Range to create value with.\n * @param {Object} value       Value that is being accumulated.\n */\nfunction accumulateSelection( accumulator, node, range, value ) {\n\tif ( ! range ) {\n\t\treturn;\n\t}\n\n\tconst { parentNode } = node;\n\tconst { startContainer, startOffset, endContainer, endOffset } = range;\n\tconst currentLength = accumulator.text.length;\n\n\t// Selection can be extracted from value.\n\tif ( value.start !== undefined ) {\n\t\taccumulator.start = currentLength + value.start;\n\t// Range indicates that the current node has selection.\n\t} else if ( node === startContainer ) {\n\t\taccumulator.start = currentLength + startOffset;\n\t// Range indicates that the current node is selected.\n\t} else if (\n\t\tparentNode === startContainer &&\n\t\tnode === startContainer.childNodes[ startOffset ]\n\t) {\n\t\taccumulator.start = currentLength;\n\t}\n\n\t// Selection can be extracted from value.\n\tif ( value.end !== undefined ) {\n\t\taccumulator.end = currentLength + value.end;\n\t// Range indicates that the current node has selection.\n\t} else if ( node === endContainer ) {\n\t\taccumulator.end = currentLength + endOffset;\n\t// Range indicates that the current node is selected.\n\t} else if (\n\t\tparentNode === endContainer &&\n\t\tnode === endContainer.childNodes[ endOffset - 1 ]\n\t) {\n\t\taccumulator.end = currentLength + value.text.length;\n\t// Range indicates that the selection is before the current node.\n\t} else if (\n\t\tparentNode === endContainer &&\n\t\tnode === endContainer.childNodes[ endOffset ]\n\t) {\n\t\taccumulator.end = currentLength;\n\t}\n}\n\n/**\n * Adjusts the start and end offsets from a range based on a text filter.\n *\n * @param {Node}     node   Node of which the text should be filtered.\n * @param {Range}    range  The range to filter.\n * @param {Function} filter Function to use to filter the text.\n *\n * @return {?Object} Object containing range properties.\n */\nfunction filterRange( node, range, filter ) {\n\tif ( ! range ) {\n\t\treturn;\n\t}\n\n\tconst { startContainer, endContainer } = range;\n\tlet { startOffset, endOffset } = range;\n\n\tif ( node === startContainer ) {\n\t\tstartOffset = filter( node.nodeValue.slice( 0, startOffset ) ).length;\n\t}\n\n\tif ( node === endContainer ) {\n\t\tendOffset = filter( node.nodeValue.slice( 0, endOffset ) ).length;\n\t}\n\n\treturn { startContainer, startOffset, endContainer, endOffset };\n}\n\n/**\n * Creates a Rich Text value from a DOM element and range.\n *\n * @param {Object}    $1                 Named argements.\n * @param {?Element}  $1.element         Element to create value from.\n * @param {?Range}    $1.range           Range to create value from.\n * @param {?Function} $1.removeNode      Function to declare whether the given\n *                                       node should be removed.\n * @param {?Function} $1.unwrapNode      Function to declare whether the given\n *                                       node should be unwrapped.\n * @param {?Function} $1.filterString    Function to filter the given string.\n * @param {?Function} $1.removeAttribute Wether to remove an attribute based on\n *                                       the name.\n *\n * @return {Object} A rich text value.\n */\nfunction createFromElement( {\n\telement,\n\trange,\n\tremoveNode,\n\tunwrapNode,\n\tfilterString,\n\tremoveAttribute,\n} ) {\n\tconst accumulator = createEmptyValue();\n\n\tif ( ! element ) {\n\t\treturn accumulator;\n\t}\n\n\tif ( ! element.hasChildNodes() ) {\n\t\taccumulateSelection( accumulator, element, range, createEmptyValue() );\n\t\treturn accumulator;\n\t}\n\n\tconst length = element.childNodes.length;\n\n\t// Remove any line breaks in text nodes. They are not content, but used to\n\t// format the HTML. Line breaks in HTML are stored as BR elements.\n\t// See https://www.w3.org/TR/html5/syntax.html#newlines.\n\tconst filterStringComplete = ( string ) => {\n\t\tstring = string.replace( /[\\r\\n]/g, '' );\n\n\t\tif ( filterString ) {\n\t\t\tstring = filterString( string );\n\t\t}\n\n\t\treturn string;\n\t};\n\n\t// Optimise for speed.\n\tfor ( let index = 0; index < length; index++ ) {\n\t\tconst node = element.childNodes[ index ];\n\n\t\tif ( node.nodeType === TEXT_NODE ) {\n\t\t\tconst text = filterStringComplete( node.nodeValue );\n\t\t\trange = filterRange( node, range, filterStringComplete );\n\t\t\taccumulateSelection( accumulator, node, range, { text } );\n\t\t\taccumulator.text += text;\n\t\t\t// Create a sparse array of the same length as `text`, in which\n\t\t\t// formats can be added.\n\t\t\taccumulator.formats.length += text.length;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ( node.nodeType !== ELEMENT_NODE ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (\n\t\t\t( removeNode && removeNode( node ) ) ||\n\t\t\t( unwrapNode && unwrapNode( node ) && ! node.hasChildNodes() )\n\t\t) {\n\t\t\taccumulateSelection( accumulator, node, range, createEmptyValue() );\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ( node.nodeName === 'BR' ) {\n\t\t\taccumulateSelection( accumulator, node, range, createEmptyValue() );\n\t\t\taccumulator.text += '\\n';\n\t\t\taccumulator.formats.length += 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst lastFormats = accumulator.formats[ accumulator.formats.length - 1 ];\n\t\tconst lastFormat = lastFormats && lastFormats[ lastFormats.length - 1 ];\n\t\tlet format;\n\n\t\tif ( ! unwrapNode || ! unwrapNode( node ) ) {\n\t\t\tconst newFormat = toFormat( {\n\t\t\t\ttype: node.nodeName.toLowerCase(),\n\t\t\t\tattributes: getAttributes( {\n\t\t\t\t\telement: node,\n\t\t\t\t\tremoveAttribute,\n\t\t\t\t} ),\n\t\t\t} );\n\n\t\t\t// Reuse the last format if it's equal.\n\t\t\tif ( isFormatEqual( newFormat, lastFormat ) ) {\n\t\t\t\tformat = lastFormat;\n\t\t\t} else {\n\t\t\t\tformat = newFormat;\n\t\t\t}\n\t\t}\n\n\t\tconst value = createFromElement( {\n\t\t\telement: node,\n\t\t\trange,\n\t\t\tremoveNode,\n\t\t\tunwrapNode,\n\t\t\tfilterString,\n\t\t\tremoveAttribute,\n\t\t} );\n\n\t\tconst text = value.text;\n\t\tconst start = accumulator.text.length;\n\n\t\taccumulateSelection( accumulator, node, range, value );\n\n\t\t// Don't apply the element as formatting if it has no content.\n\t\tif ( isEmpty( value ) && format && ! format.attributes ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst { formats } = accumulator;\n\n\t\tif ( format && format.attributes && text.length === 0 ) {\n\t\t\tformat.object = true;\n\t\t\t// Object replacement character.\n\t\t\taccumulator.text += '\\ufffc';\n\n\t\t\tif ( formats[ start ] ) {\n\t\t\t\tformats[ start ].unshift( format );\n\t\t\t} else {\n\t\t\t\tformats[ start ] = [ format ];\n\t\t\t}\n\t\t} else {\n\t\t\taccumulator.text += text;\n\n\t\t\tlet i = value.formats.length;\n\n\t\t\t// Optimise for speed.\n\t\t\twhile ( i-- ) {\n\t\t\t\tconst formatIndex = start + i;\n\n\t\t\t\tif ( format ) {\n\t\t\t\t\tif ( formats[ formatIndex ] ) {\n\t\t\t\t\t\tformats[ formatIndex ].push( format );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tformats[ formatIndex ] = [ format ];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( value.formats[ i ] ) {\n\t\t\t\t\tif ( formats[ formatIndex ] ) {\n\t\t\t\t\t\tformats[ formatIndex ].push( ...value.formats[ i ] );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tformats[ formatIndex ] = value.formats[ i ];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn accumulator;\n}\n\n/**\n * Creates a rich text value from a DOM element and range that should be\n * multiline.\n *\n * @param {Object}    $1                 Named argements.\n * @param {?Element}  $1.element         Element to create value from.\n * @param {?Range}    $1.range           Range to create value from.\n * @param {?string}   $1.multilineTag    Multiline tag if the structure is\n *                                       multiline.\n * @param {?Function} $1.removeNode      Function to declare whether the given\n *                                       node should be removed.\n * @param {?Function} $1.unwrapNode      Function to declare whether the given\n *                                       node should be unwrapped.\n * @param {?Function} $1.filterString    Function to filter the given string.\n * @param {?Function} $1.removeAttribute Wether to remove an attribute based on\n *                                       the name.\n *\n * @return {Object} A rich text value.\n */\nfunction createFromMultilineElement( {\n\telement,\n\trange,\n\tmultilineTag,\n\tremoveNode,\n\tunwrapNode,\n\tfilterString,\n\tremoveAttribute,\n} ) {\n\tconst accumulator = createEmptyValue();\n\n\tif ( ! element || ! element.hasChildNodes() ) {\n\t\treturn accumulator;\n\t}\n\n\tconst length = element.children.length;\n\n\t// Optimise for speed.\n\tfor ( let index = 0; index < length; index++ ) {\n\t\tconst node = element.children[ index ];\n\n\t\tif ( node.nodeName.toLowerCase() !== multilineTag ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst value = createFromElement( {\n\t\t\telement: node,\n\t\t\trange,\n\t\t\tmultilineTag,\n\t\t\tremoveNode,\n\t\t\tunwrapNode,\n\t\t\tfilterString,\n\t\t\tremoveAttribute,\n\t\t} );\n\n\t\t// Multiline value text should be separated by a double line break.\n\t\tif ( index !== 0 ) {\n\t\t\taccumulator.formats = accumulator.formats.concat( [ , ] );\n\t\t\taccumulator.text += '\\u2028';\n\t\t}\n\n\t\taccumulateSelection( accumulator, node, range, value );\n\n\t\taccumulator.formats = accumulator.formats.concat( value.formats );\n\t\taccumulator.text += value.text;\n\t}\n\n\treturn accumulator;\n}\n\n/**\n * Gets the attributes of an element in object shape.\n *\n * @param {Object}    $1                 Named argements.\n * @param {Element}   $1.element         Element to get attributes from.\n * @param {?Function} $1.removeAttribute Wether to remove an attribute based on\n *                                       the name.\n *\n * @return {?Object} Attribute object or `undefined` if the element has no\n *                   attributes.\n */\nfunction getAttributes( {\n\telement,\n\tremoveAttribute,\n} ) {\n\tif ( ! element.hasAttributes() ) {\n\t\treturn;\n\t}\n\n\tconst length = element.attributes.length;\n\tlet accumulator;\n\n\t// Optimise for speed.\n\tfor ( let i = 0; i < length; i++ ) {\n\t\tconst { name, value } = element.attributes[ i ];\n\n\t\tif ( removeAttribute && removeAttribute( name ) ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\taccumulator = accumulator || {};\n\t\taccumulator[ name ] = value;\n\t}\n\n\treturn accumulator;\n}\n","/**\n * External dependencies\n */\n\nimport { find } from 'lodash';\n\n/**\n * Gets the format object by type at the start of the selection. This can be\n * used to get e.g. the URL of a link format at the current selection, but also\n * to check if a format is active at the selection. Returns undefined if there\n * is no format at the selection.\n *\n * @param {Object} value      Value to inspect.\n * @param {string} formatType Format type to look for.\n *\n * @return {?Object} Active format object of the specified type, or undefined.\n */\nexport function getActiveFormat( { formats, start }, formatType ) {\n\tif ( start === undefined ) {\n\t\treturn;\n\t}\n\n\treturn find( formats[ start ], { type: formatType } );\n}\n","/**\n * WordPress dependencies\n */\nimport { select } from '@wordpress/data';\n\n/**\n * Returns a registered format type.\n *\n * @param {string} name Format name.\n *\n * @return {?Object} Format type.\n */\nexport function getFormatType( name ) {\n\treturn select( 'core/rich-text' ).getFormatType( name );\n}\n","/**\n * WordPress dependencies\n */\nimport { select } from '@wordpress/data';\n\n/**\n * Returns all registered formats.\n *\n * @return {Array} Format settings.\n */\nexport function getFormatTypes() {\n\treturn select( 'core/rich-text' ).getFormatTypes();\n}\n","/**\n * Get the textual content of a Rich Text value. This is similar to\n * `Element.textContent`.\n *\n * @param {Object} value Value to use.\n *\n * @return {string} The text content.\n */\nexport function getTextContent( { text } ) {\n\treturn text;\n}\n","import './store';\n\nexport { applyFormat } from './apply-format';\nexport { concat } from './concat';\nexport { create } from './create';\nexport { getActiveFormat } from './get-active-format';\nexport { getFormatType } from './get-format-type';\nexport { getFormatTypes } from './get-format-types';\nexport { getTextContent } from './get-text-content';\nexport { isCollapsed } from './is-collapsed';\nexport { isEmpty, isEmptyLine } from './is-empty';\nexport { join } from './join';\nexport { registerFormatType } from './register-format-type';\nexport { removeFormat } from './remove-format';\nexport { remove } from './remove';\nexport { replace } from './replace';\nexport { insert } from './insert';\nexport { insertObject } from './insert-object';\nexport { slice } from './slice';\nexport { split } from './split';\nexport { apply, toDom as unstableToDom } from './to-dom';\nexport { toHTMLString } from './to-html-string';\nexport { toggleFormat } from './toggle-format';\nexport { unregisterFormatType } from './unregister-format-type';\n","/**\n * Internal dependencies\n */\n\nimport { insert } from './insert';\n\nconst OBJECT_REPLACEMENT_CHARACTER = '\\ufffc';\n\n/**\n * Insert a format as an object into a Rich Text value at the given\n * `startIndex`. Any content between `startIndex` and `endIndex` will be\n * removed. Indices are retrieved from the selection if none are provided.\n *\n * @param {Object} value          Value to modify.\n * @param {string} formatToInsert Format to insert as object.\n * @param {number} startIndex     Start index.\n * @param {number} endIndex       End index.\n *\n * @return {Object} A new value with the object inserted.\n */\nexport function insertObject(\n\tvalue,\n\tformatToInsert,\n\tstartIndex,\n\tendIndex\n) {\n\tconst valueToInsert = {\n\t\ttext: OBJECT_REPLACEMENT_CHARACTER,\n\t\tformats: [ [ {\n\t\t\t...formatToInsert,\n\t\t\tobject: true,\n\t\t} ] ],\n\t};\n\n\treturn insert( value, valueToInsert, startIndex, endIndex );\n}\n","/**\n * Internal dependencies\n */\n\nimport { create } from './create';\nimport { normaliseFormats } from './normalise-formats';\n\n/**\n * Insert a Rich Text value, an HTML string, or a plain text string, into a\n * Rich Text value at the given `startIndex`. Any content between `startIndex`\n * and `endIndex` will be removed. Indices are retrieved from the selection if\n * none are provided.\n *\n * @param {Object} value         Value to modify.\n * @param {string} valueToInsert Value to insert.\n * @param {number} startIndex    Start index.\n * @param {number} endIndex      End index.\n *\n * @return {Object} A new value with the value inserted.\n */\nexport function insert(\n\t{ formats, text, start, end },\n\tvalueToInsert,\n\tstartIndex = start,\n\tendIndex = end\n) {\n\tif ( typeof valueToInsert === 'string' ) {\n\t\tvalueToInsert = create( { text: valueToInsert } );\n\t}\n\n\tconst index = startIndex + valueToInsert.text.length;\n\n\treturn normaliseFormats( {\n\t\tformats: formats.slice( 0, startIndex ).concat( valueToInsert.formats, formats.slice( endIndex ) ),\n\t\ttext: text.slice( 0, startIndex ) + valueToInsert.text + text.slice( endIndex ),\n\t\tstart: index,\n\t\tend: index,\n\t} );\n}\n","/**\n * Check if the selection of a Rich Text value is collapsed or not. Collapsed\n * means that no characters are selected, but there is a caret present. If there\n * is no selection, `undefined` will be returned. This is similar to\n * `window.getSelection().isCollapsed()`.\n *\n * @param {Object} value The rich text value to check.\n *\n * @return {?boolean} True if the selection is collapsed, false if not,\n *                    undefined if there is no selection.\n */\nexport function isCollapsed( { start, end } ) {\n\tif ( start === undefined || end === undefined ) {\n\t\treturn;\n\t}\n\n\treturn start === end;\n}\n","/**\n * Check if a Rich Text value is Empty, meaning it contains no text or any\n * objects (such as images).\n *\n * @param {Object} value Value to use.\n *\n * @return {boolean} True if the value is empty, false if not.\n */\nexport function isEmpty( { text } ) {\n\treturn text.length === 0;\n}\n\n/**\n * Check if the current collapsed selection is on an empty line in case of a\n * multiline value.\n *\n * @param  {Object} value Value te check.\n *\n * @return {boolean} True if the line is empty, false if not.\n */\nexport function isEmptyLine( { text, start, end } ) {\n\tif ( start !== end ) {\n\t\treturn false;\n\t}\n\n\tif ( text.length === 0 ) {\n\t\treturn true;\n\t}\n\n\tif ( start === 0 && text.slice( 0, 1 ) === '\\u2028' ) {\n\t\treturn true;\n\t}\n\n\tif ( start === text.length && text.slice( -1 ) === '\\u2028' ) {\n\t\treturn true;\n\t}\n\n\treturn text.slice( start - 1, end + 1 ) === '\\u2028\\u2028';\n}\n","/**\n * Optimised equality check for format objects.\n *\n * @param {?Object} format1 Format to compare.\n * @param {?Object} format2 Format to compare.\n *\n * @return {boolean} True if formats are equal, false if not.\n */\nexport function isFormatEqual( format1, format2 ) {\n\t// Both not defined.\n\tif ( format1 === format2 ) {\n\t\treturn true;\n\t}\n\n\t// Either not defined.\n\tif ( ! format1 || ! format2 ) {\n\t\treturn false;\n\t}\n\n\tif ( format1.type !== format2.type ) {\n\t\treturn false;\n\t}\n\n\tconst attributes1 = format1.attributes;\n\tconst attributes2 = format2.attributes;\n\n\t// Both not defined.\n\tif ( attributes1 === attributes2 ) {\n\t\treturn true;\n\t}\n\n\t// Either not defined.\n\tif ( ! attributes1 || ! attributes2 ) {\n\t\treturn false;\n\t}\n\n\tconst keys1 = Object.keys( attributes1 );\n\tconst keys2 = Object.keys( attributes2 );\n\n\tif ( keys1.length !== keys2.length ) {\n\t\treturn false;\n\t}\n\n\tconst length = keys1.length;\n\n\t// Optimise for speed.\n\tfor ( let i = 0; i < length; i++ ) {\n\t\tconst name = keys1[ i ];\n\n\t\tif ( attributes1[ name ] !== attributes2[ name ] ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n","/**\n * Internal dependencies\n */\n\nimport { create } from './create';\nimport { normaliseFormats } from './normalise-formats';\n\n/**\n * Combine an array of Rich Text values into one, optionally separated by\n * `separator`, which can be a Rich Text value, HTML string, or plain text\n * string. This is similar to `Array.prototype.join`.\n *\n * @param {Array}         values    An array of values to join.\n * @param {string|Object} separator Separator string or value.\n *\n * @return {Object} A new combined value.\n */\nexport function join( values, separator = '' ) {\n\tif ( typeof separator === 'string' ) {\n\t\tseparator = create( { text: separator } );\n\t}\n\n\treturn normaliseFormats( values.reduce( ( accumlator, { formats, text } ) => ( {\n\t\ttext: accumlator.text + separator.text + text,\n\t\tformats: accumlator.formats.concat( separator.formats, formats ),\n\t} ) ) );\n}\n","/**\n * Internal dependencies\n */\n\nimport { isFormatEqual } from './is-format-equal';\n\n/**\n * Normalises formats: ensures subsequent equal formats have the same reference.\n *\n * @param  {Object} value Value to normalise formats of.\n *\n * @return {Object} New value with normalised formats.\n */\nexport function normaliseFormats( { formats, text, start, end } ) {\n\tconst newFormats = formats.slice( 0 );\n\n\tnewFormats.forEach( ( formatsAtIndex, index ) => {\n\t\tconst lastFormatsAtIndex = newFormats[ index - 1 ];\n\n\t\tif ( lastFormatsAtIndex ) {\n\t\t\tconst newFormatsAtIndex = formatsAtIndex.slice( 0 );\n\n\t\t\tnewFormatsAtIndex.forEach( ( format, formatIndex ) => {\n\t\t\t\tconst lastFormat = lastFormatsAtIndex[ formatIndex ];\n\n\t\t\t\tif ( isFormatEqual( format, lastFormat ) ) {\n\t\t\t\t\tnewFormatsAtIndex[ formatIndex ] = lastFormat;\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\tnewFormats[ index ] = newFormatsAtIndex;\n\t\t}\n\t} );\n\n\treturn { formats: newFormats, text, start, end };\n}\n","/**\n * External dependencies\n */\nimport { isFunction } from 'lodash';\n\n/**\n * WordPress dependencies\n */\nimport { select, dispatch } from '@wordpress/data';\n\n/**\n * Registers a new format provided a unique name and an object defining its\n * behavior.\n *\n * @param {string} name     Format name.\n * @param {Object} settings Format settings.\n *\n * @return {?WPFormat} The format, if it has been successfully registered;\n *                     otherwise `undefined`.\n */\nexport function registerFormatType( name, settings ) {\n\tsettings = {\n\t\tname,\n\t\t...settings,\n\t};\n\n\tif ( typeof settings.name !== 'string' ) {\n\t\twindow.console.error(\n\t\t\t'Format names must be strings.'\n\t\t);\n\t\treturn;\n\t}\n\n\tif ( ! /^[a-z][a-z0-9-]*\\/[a-z][a-z0-9-]*$/.test( settings.name ) ) {\n\t\twindow.console.error(\n\t\t\t'Format names must contain a namespace prefix, include only lowercase alphanumeric characters or dashes, and start with a letter. Example: my-plugin/my-custom-format'\n\t\t);\n\t\treturn;\n\t}\n\n\tif ( select( 'core/rich-text' ).getFormatType( settings.name ) ) {\n\t\twindow.console.error(\n\t\t\t'Format \"' + settings.name + '\" is already registered.'\n\t\t);\n\t\treturn;\n\t}\n\n\tif ( ! settings || ! isFunction( settings.edit ) ) {\n\t\twindow.console.error(\n\t\t\t'The \"edit\" property must be specified and must be a valid function.'\n\t\t);\n\t\treturn;\n\t}\n\n\tif ( ! ( 'title' in settings ) || settings.title === '' ) {\n\t\twindow.console.error(\n\t\t\t'The format \"' + settings.name + '\" must have a title.'\n\t\t);\n\t\treturn;\n\t}\n\n\tif ( 'keywords' in settings && settings.keywords.length > 3 ) {\n\t\twindow.console.error(\n\t\t\t'The format \"' + settings.name + '\" can have a maximum of 3 keywords.'\n\t\t);\n\t\treturn;\n\t}\n\n\tif ( typeof settings.title !== 'string' ) {\n\t\twindow.console.error(\n\t\t\t'Format titles must be strings.'\n\t\t);\n\t\treturn;\n\t}\n\n\tdispatch( 'core/rich-text' ).addFormatTypes( settings );\n\n\treturn settings;\n}\n","/**\n * External dependencies\n */\n\nimport { find } from 'lodash';\n\n/**\n * Internal dependencies\n */\n\nimport { normaliseFormats } from './normalise-formats';\n\n/**\n * Remove any format object from a Rich Text value by type from the given\n * `startIndex` to the given `endIndex`. Indices are retrieved from the\n * selection if none are provided.\n *\n * @param {Object} value      Value to modify.\n * @param {string} formatType Format type to remove.\n * @param {number} startIndex Start index.\n * @param {number} endIndex   End index.\n *\n * @return {Object} A new value with the format applied.\n */\nexport function removeFormat(\n\t{ formats, text, start, end },\n\tformatType,\n\tstartIndex = start,\n\tendIndex = end\n) {\n\tconst newFormats = formats.slice( 0 );\n\n\t// If the selection is collapsed, expand start and end to the edges of the\n\t// format.\n\tif ( startIndex === endIndex ) {\n\t\tconst format = find( newFormats[ startIndex ], { type: formatType } );\n\n\t\twhile ( find( newFormats[ startIndex ], format ) ) {\n\t\t\tfilterFormats( newFormats, startIndex, formatType );\n\t\t\tstartIndex--;\n\t\t}\n\n\t\tendIndex++;\n\n\t\twhile ( find( newFormats[ endIndex ], format ) ) {\n\t\t\tfilterFormats( newFormats, endIndex, formatType );\n\t\t\tendIndex++;\n\t\t}\n\t} else {\n\t\tfor ( let i = startIndex; i < endIndex; i++ ) {\n\t\t\tif ( newFormats[ i ] ) {\n\t\t\t\tfilterFormats( newFormats, i, formatType );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn normaliseFormats( { formats: newFormats, text, start, end } );\n}\n\nfunction filterFormats( formats, index, formatType ) {\n\tconst newFormats = formats[ index ].filter( ( { type } ) => type !== formatType );\n\n\tif ( newFormats.length ) {\n\t\tformats[ index ] = newFormats;\n\t} else {\n\t\tdelete formats[ index ];\n\t}\n}\n","/**\n * Internal dependencies\n */\n\nimport { insert } from './insert';\nimport { create } from './create';\n\n/**\n * Remove content from a Rich Text value between the given `startIndex` and\n * `endIndex`. Indices are retrieved from the selection if none are provided.\n *\n * @param {Object} value      Value to modify.\n * @param {number} startIndex Start index.\n * @param {number} endIndex   End index.\n *\n * @return {Object} A new value with the content removed.\n */\nexport function remove( value, startIndex, endIndex ) {\n\treturn insert( value, create(), startIndex, endIndex );\n}\n","/**\n * Internal dependencies\n */\n\nimport { normaliseFormats } from './normalise-formats';\n\n/**\n * Search a Rich Text value and replace the match(es) with `replacement`. This\n * is similar to `String.prototype.replace`.\n *\n * @param {Object}         value        The value to modify.\n * @param {RegExp|string}  pattern      A RegExp object or literal. Can also be\n *                                      a string. It is treated as a verbatim\n *                                      string and is not interpreted as a\n *                                      regular expression. Only the first\n *                                      occurrence will be replaced.\n * @param {Function|string} replacement The match or matches are replaced with\n *                                      the specified or the value returned by\n *                                      the specified function.\n *\n * @return {Object} A new value with replacements applied.\n */\nexport function replace( { formats, text, start, end }, pattern, replacement ) {\n\ttext = text.replace( pattern, ( match, ...rest ) => {\n\t\tconst offset = rest[ rest.length - 2 ];\n\t\tlet newText = replacement;\n\t\tlet newFormats;\n\n\t\tif ( typeof newText === 'function' ) {\n\t\t\tnewText = replacement( match, ...rest );\n\t\t}\n\n\t\tif ( typeof newText === 'object' ) {\n\t\t\tnewFormats = newText.formats;\n\t\t\tnewText = newText.text;\n\t\t} else {\n\t\t\tnewFormats = Array( newText.length );\n\n\t\t\tif ( formats[ offset ] ) {\n\t\t\t\tnewFormats = newFormats.fill( formats[ offset ] );\n\t\t\t}\n\t\t}\n\n\t\tformats = formats.slice( 0, offset ).concat( newFormats, formats.slice( offset + match.length ) );\n\n\t\tif ( start ) {\n\t\t\tstart = end = offset + newText.length;\n\t\t}\n\n\t\treturn newText;\n\t} );\n\n\treturn normaliseFormats( { formats, text, start, end } );\n}\n","/**\n * Slice a Rich Text value from `startIndex` to `endIndex`. Indices are\n * retrieved from the selection if none are provided. This is similar to\n * `String.prototype.slice`.\n *\n * @param {Object} value       Value to modify.\n * @param {number} startIndex  Start index.\n * @param {number} endIndex    End index.\n *\n * @return {Object} A new extracted value.\n */\nexport function slice(\n\t{ formats, text, start, end },\n\tstartIndex = start,\n\tendIndex = end\n) {\n\tif ( startIndex === undefined || endIndex === undefined ) {\n\t\treturn { formats, text };\n\t}\n\n\treturn {\n\t\tformats: formats.slice( startIndex, endIndex ),\n\t\ttext: text.slice( startIndex, endIndex ),\n\t};\n}\n","export const ZERO_WIDTH_NO_BREAK_SPACE = '\\uFEFF';\n","/**\n * Internal dependencies\n */\n\nimport { replace } from './replace';\n\n/**\n * Split a Rich Text value in two at the given `startIndex` and `endIndex`, or\n * split at the given separator. This is similar to `String.prototype.split`.\n * Indices are retrieved from the selection if none are provided.\n *\n * @param {Object}        value   Value to modify.\n * @param {number|string} string  Start index, or string at which to split.\n * @param {number}        end     End index.\n *\n * @return {Array} An array of new values.\n */\nexport function split( { formats, text, start, end }, string ) {\n\tif ( typeof string !== 'string' ) {\n\t\treturn splitAtSelection( ...arguments );\n\t}\n\n\tlet nextStart = 0;\n\n\treturn text.split( string ).map( ( substring ) => {\n\t\tconst startIndex = nextStart;\n\t\tconst value = {\n\t\t\tformats: formats.slice( startIndex, startIndex + substring.length ),\n\t\t\ttext: substring,\n\t\t};\n\n\t\tnextStart += string.length + substring.length;\n\n\t\tif ( start !== undefined && end !== undefined ) {\n\t\t\tif ( start >= startIndex && start < nextStart ) {\n\t\t\t\tvalue.start = start - startIndex;\n\t\t\t} else if ( start < startIndex && end > startIndex ) {\n\t\t\t\tvalue.start = 0;\n\t\t\t}\n\n\t\t\tif ( end >= startIndex && end < nextStart ) {\n\t\t\t\tvalue.end = end - startIndex;\n\t\t\t} else if ( start < nextStart && end > nextStart ) {\n\t\t\t\tvalue.end = substring.length;\n\t\t\t}\n\t\t}\n\n\t\treturn value;\n\t} );\n}\n\nfunction splitAtSelection(\n\t{ formats, text, start, end },\n\tstartIndex = start,\n\tendIndex = end\n) {\n\tconst before = {\n\t\tformats: formats.slice( 0, startIndex ),\n\t\ttext: text.slice( 0, startIndex ),\n\t};\n\tconst after = {\n\t\tformats: formats.slice( endIndex ),\n\t\ttext: text.slice( endIndex ),\n\t\tstart: 0,\n\t\tend: 0,\n\t};\n\n\treturn [\n\t\t// Ensure newlines are trimmed.\n\t\treplace( before, /\\u2028+$/, '' ),\n\t\treplace( after, /^\\u2028+/, '' ),\n\t];\n}\n","/**\n * External dependencies\n */\nimport { castArray } from 'lodash';\n\n/**\n * Returns an action object used in signalling that format types have been\n * added.\n *\n * @param {Array|Object} formatTypes Format types received.\n *\n * @return {Object} Action object.\n */\nexport function addFormatTypes( formatTypes ) {\n\treturn {\n\t\ttype: 'ADD_FORMAT_TYPES',\n\t\tformatTypes: castArray( formatTypes ),\n\t};\n}\n\n/**\n * Returns an action object used to remove a registered format type.\n *\n * @param {string|Array} names Format name.\n *\n * @return {Object} Action object.\n */\nexport function removeFormatTypes( names ) {\n\treturn {\n\t\ttype: 'REMOVE_FORMAT_TYPES',\n\t\tnames: castArray( names ),\n\t};\n}\n","/**\n * WordPress dependencies\n */\nimport { registerStore } from '@wordpress/data';\n\n/**\n * Internal dependencies\n */\nimport reducer from './reducer';\nimport * as selectors from './selectors';\nimport * as actions from './actions';\n\nregisterStore( 'core/rich-text', { reducer, selectors, actions } );\n","/**\n * External dependencies\n */\nimport { keyBy, omit } from 'lodash';\n\n/**\n * WordPress dependencies\n */\nimport { combineReducers } from '@wordpress/data';\n\n/**\n * Reducer managing the format types\n *\n * @param {Object} state  Current state.\n * @param {Object} action Dispatched action.\n *\n * @return {Object} Updated state.\n */\nexport function formatTypes( state = {}, action ) {\n\tswitch ( action.type ) {\n\t\tcase 'ADD_FORMAT_TYPES':\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\t...keyBy( action.formatTypes, 'name' ),\n\t\t\t};\n\t\tcase 'REMOVE_FORMAT_TYPES':\n\t\t\treturn omit( state, action.names );\n\t}\n\n\treturn state;\n}\n\nexport default combineReducers( { formatTypes } );\n","/**\n * External dependencies\n */\nimport createSelector from 'rememo';\n\n/**\n * Returns all the available format types.\n *\n * @param {Object} state Data state.\n *\n * @return {Array} Format types.\n */\nexport const getFormatTypes = createSelector(\n\t( state ) => Object.values( state.formatTypes ),\n\t( state ) => [\n\t\tstate.formatTypes,\n\t]\n);\n\n/**\n * Returns a format type by name.\n *\n * @param {Object} state Data state.\n * @param {string} name Format type name.\n *\n * @return {Object?} Format type.\n */\nexport function getFormatType( state, name ) {\n\treturn state.formatTypes[ name ];\n}\n","/**\n * Internal dependencies\n */\n\nimport { toTree } from './to-tree';\n\n/**\n * Browser dependencies\n */\n\nconst { TEXT_NODE, ELEMENT_NODE } = window.Node;\n\n/**\n * Creates a path as an array of indices from the given root node to the given\n * node.\n *\n * @param {Node}        node     Node to find the path of.\n * @param {HTMLElement} rootNode Root node to find the path from.\n * @param {Array}       path     Initial path to build on.\n *\n * @return {Array} The path from the root node to the node.\n */\nfunction createPathToNode( node, rootNode, path ) {\n\tconst parentNode = node.parentNode;\n\tlet i = 0;\n\n\twhile ( ( node = node.previousSibling ) ) {\n\t\ti++;\n\t}\n\n\tpath = [ i, ...path ];\n\n\tif ( parentNode !== rootNode ) {\n\t\tpath = createPathToNode( parentNode, rootNode, path );\n\t}\n\n\treturn path;\n}\n\n/**\n * Gets a node given a path (array of indices) from the given node.\n *\n * @param {HTMLElement} node Root node to find the wanted node in.\n * @param {Array}       path Path (indices) to the wanted node.\n *\n * @return {Object} Object with the found node and the remaining offset (if any).\n */\nfunction getNodeByPath( node, path ) {\n\tpath = [ ...path ];\n\n\twhile ( node && path.length > 1 ) {\n\t\tnode = node.childNodes[ path.shift() ];\n\t}\n\n\treturn {\n\t\tnode,\n\t\toffset: path[ 0 ],\n\t};\n}\n\nfunction createEmpty( type ) {\n\tconst { body } = document.implementation.createHTMLDocument( '' );\n\n\tif ( type ) {\n\t\treturn body.appendChild( body.ownerDocument.createElement( type ) );\n\t}\n\n\treturn body;\n}\n\nfunction append( element, child ) {\n\tif ( typeof child === 'string' ) {\n\t\tchild = element.ownerDocument.createTextNode( child );\n\t}\n\n\tconst { type, attributes } = child;\n\n\tif ( type ) {\n\t\tchild = element.ownerDocument.createElement( type );\n\n\t\tfor ( const key in attributes ) {\n\t\t\tchild.setAttribute( key, attributes[ key ] );\n\t\t}\n\t}\n\n\treturn element.appendChild( child );\n}\n\nfunction appendText( node, text ) {\n\tnode.appendData( text );\n}\n\nfunction getLastChild( { lastChild } ) {\n\treturn lastChild;\n}\n\nfunction getParent( { parentNode } ) {\n\treturn parentNode;\n}\n\nfunction isText( { nodeType } ) {\n\treturn nodeType === TEXT_NODE;\n}\n\nfunction getText( { nodeValue } ) {\n\treturn nodeValue;\n}\n\nfunction remove( node ) {\n\treturn node.parentNode.removeChild( node );\n}\n\nexport function toDom( value, multilineTag ) {\n\tlet startPath = [];\n\tlet endPath = [];\n\n\tconst tree = toTree( value, multilineTag, {\n\t\tcreateEmpty,\n\t\tappend,\n\t\tgetLastChild,\n\t\tgetParent,\n\t\tisText,\n\t\tgetText,\n\t\tremove,\n\t\tappendText,\n\t\tonStartIndex( body, pointer, multilineIndex ) {\n\t\t\tstartPath = createPathToNode( pointer, body, [ pointer.nodeValue.length ] );\n\n\t\t\tif ( multilineIndex !== undefined ) {\n\t\t\t\tstartPath = [ multilineIndex, ...startPath ];\n\t\t\t}\n\t\t},\n\t\tonEndIndex( body, pointer, multilineIndex ) {\n\t\t\tendPath = createPathToNode( pointer, body, [ pointer.nodeValue.length ] );\n\n\t\t\tif ( multilineIndex !== undefined ) {\n\t\t\t\tendPath = [ multilineIndex, ...endPath ];\n\t\t\t}\n\t\t},\n\t\tonEmpty( body ) {\n\t\t\tconst br = body.ownerDocument.createElement( 'br' );\n\t\t\tbr.setAttribute( 'data-mce-bogus', '1' );\n\t\t\tbody.appendChild( br );\n\t\t},\n\t} );\n\n\treturn {\n\t\tbody: tree,\n\t\tselection: { startPath, endPath },\n\t};\n}\n\n/**\n * Create an `Element` tree from a Rich Text value and applies the difference to\n * the `Element` tree contained by `current`. If a `multilineTag` is provided,\n * text separated by two new lines will be wrapped in an `Element` of that type.\n *\n * @param {Object}      value        Value to apply.\n * @param {HTMLElement} current      The live root node to apply the element\n *                                   tree to.\n * @param {string}      multilineTag Multiline tag.\n */\nexport function apply( value, current, multilineTag ) {\n\t// Construct a new element tree in memory.\n\tconst { body, selection } = toDom( value, multilineTag );\n\n\tapplyValue( body, current );\n\n\tif ( value.start !== undefined ) {\n\t\tapplySelection( selection, current );\n\t}\n}\n\nexport function applyValue( future, current ) {\n\tlet i = 0;\n\n\twhile ( future.firstChild ) {\n\t\tconst currentChild = current.childNodes[ i ];\n\t\tconst futureNodeType = future.firstChild.nodeType;\n\n\t\tif ( ! currentChild ) {\n\t\t\tcurrent.appendChild( future.firstChild );\n\t\t} else if (\n\t\t\tfutureNodeType !== currentChild.nodeType ||\n\t\t\tfutureNodeType !== TEXT_NODE ||\n\t\t\tfuture.firstChild.nodeValue !== currentChild.nodeValue\n\t\t) {\n\t\t\tcurrent.replaceChild( future.firstChild, currentChild );\n\t\t} else {\n\t\t\tfuture.removeChild( future.firstChild );\n\t\t}\n\n\t\ti++;\n\t}\n\n\twhile ( current.childNodes[ i ] ) {\n\t\tcurrent.removeChild( current.childNodes[ i ] );\n\t}\n}\n\nexport function applySelection( selection, current ) {\n\tconst { node: startContainer, offset: startOffset } = getNodeByPath( current, selection.startPath );\n\tconst { node: endContainer, offset: endOffset } = getNodeByPath( current, selection.endPath );\n\n\tconst windowSelection = window.getSelection();\n\tconst range = current.ownerDocument.createRange();\n\tconst collapsed = startContainer === endContainer && startOffset === endOffset;\n\n\tif (\n\t\tcollapsed &&\n\t\tstartOffset === 0 &&\n\t\tstartContainer.previousSibling &&\n\t\tstartContainer.previousSibling.nodeType === ELEMENT_NODE &&\n\t\tstartContainer.previousSibling.nodeName !== 'BR'\n\t) {\n\t\tstartContainer.insertData( 0, '\\uFEFF' );\n\t\trange.setStart( startContainer, 1 );\n\t\trange.setEnd( endContainer, 1 );\n\t} else if (\n\t\tcollapsed &&\n\t\tstartOffset === 0 &&\n\t\tstartContainer === TEXT_NODE &&\n\t\tstartContainer.nodeValue.length === 0\n\t) {\n\t\tstartContainer.insertData( 0, '\\uFEFF' );\n\t\trange.setStart( startContainer, 1 );\n\t\trange.setEnd( endContainer, 1 );\n\t} else {\n\t\trange.setStart( startContainer, startOffset );\n\t\trange.setEnd( endContainer, endOffset );\n\t}\n\n\twindowSelection.removeAllRanges();\n\twindowSelection.addRange( range );\n}\n","/**\n * Internal dependencies\n */\n\nimport {\n\tescapeHTML,\n\tescapeAttribute,\n\tisValidAttributeName,\n} from '@wordpress/escape-html';\n\n/**\n * Internal dependencies\n */\n\nimport { toTree } from './to-tree';\n\n/**\n * Create an HTML string from a Rich Text value. If a `multilineTag` is\n * provided, text separated by two new lines will be wrapped in it.\n *\n * @param {Object} value        Rich text value.\n * @param {string} multilineTag Multiline tag.\n *\n * @return {string} HTML string.\n */\nexport function toHTMLString( value, multilineTag ) {\n\tconst tree = toTree( value, multilineTag, {\n\t\tcreateEmpty,\n\t\tappend,\n\t\tgetLastChild,\n\t\tgetParent,\n\t\tisText,\n\t\tgetText,\n\t\tremove,\n\t\tappendText,\n\t} );\n\n\treturn createChildrenHTML( tree.children );\n}\n\nfunction createEmpty( type ) {\n\treturn { type };\n}\n\nfunction getLastChild( { children } ) {\n\treturn children && children[ children.length - 1 ];\n}\n\nfunction append( parent, object ) {\n\tif ( typeof object === 'string' ) {\n\t\tobject = { text: object };\n\t}\n\n\tobject.parent = parent;\n\tparent.children = parent.children || [];\n\tparent.children.push( object );\n\treturn object;\n}\n\nfunction appendText( object, text ) {\n\tobject.text += text;\n}\n\nfunction getParent( { parent } ) {\n\treturn parent;\n}\n\nfunction isText( { text } ) {\n\treturn typeof text === 'string';\n}\n\nfunction getText( { text } ) {\n\treturn text;\n}\n\nfunction remove( object ) {\n\tconst index = object.parent.children.indexOf( object );\n\n\tif ( index !== -1 ) {\n\t\tobject.parent.children.splice( index, 1 );\n\t}\n\n\treturn object;\n}\n\nfunction createElementHTML( { type, attributes, object, children } ) {\n\tlet attributeString = '';\n\n\tfor ( const key in attributes ) {\n\t\tif ( ! isValidAttributeName( key ) ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tattributeString += ` ${ key }=\"${ escapeAttribute( attributes[ key ] ) }\"`;\n\t}\n\n\tif ( object ) {\n\t\treturn `<${ type }${ attributeString }>`;\n\t}\n\n\treturn `<${ type }${ attributeString }>${ createChildrenHTML( children ) }</${ type }>`;\n}\n\nfunction createChildrenHTML( children = [] ) {\n\treturn children.map( ( child ) => {\n\t\treturn child.text === undefined ? createElementHTML( child ) : escapeHTML( child.text );\n\t} ).join( '' );\n}\n","/**\n * Internal dependencies\n */\n\nimport { split } from './split';\nimport { getFormatType } from './get-format-type';\n\nfunction fromFormat( { type, attributes, object } ) {\n\tconst formatType = getFormatType( type );\n\n\tif ( ! formatType ) {\n\t\treturn { type, attributes, object };\n\t}\n\n\tif ( ! attributes ) {\n\t\treturn {\n\t\t\ttype: formatType.match.tagName,\n\t\t\tobject: formatType.object,\n\t\t};\n\t}\n\n\tconst elementAttributes = {};\n\n\tfor ( const name in attributes ) {\n\t\tconst key = formatType.attributes[ name ];\n\n\t\tif ( key ) {\n\t\t\telementAttributes[ key ] = attributes[ name ];\n\t\t} else {\n\t\t\telementAttributes[ name ] = attributes[ name ];\n\t\t}\n\t}\n\n\treturn {\n\t\ttype: formatType.match.tagName,\n\t\tobject: formatType.object,\n\t\tattributes: elementAttributes,\n\t};\n}\n\nexport function toTree( value, multilineTag, settings ) {\n\tif ( multilineTag ) {\n\t\tconst { createEmpty, append } = settings;\n\t\tconst tree = createEmpty();\n\n\t\tsplit( value, '\\u2028' ).forEach( ( piece, index ) => {\n\t\t\tappend( tree, toTree( piece, null, {\n\t\t\t\t...settings,\n\t\t\t\ttag: multilineTag,\n\t\t\t\tmultilineIndex: index,\n\t\t\t} ) );\n\t\t} );\n\n\t\treturn tree;\n\t}\n\n\tconst {\n\t\ttag,\n\t\tmultilineIndex,\n\t\tcreateEmpty,\n\t\tappend,\n\t\tgetLastChild,\n\t\tgetParent,\n\t\tisText,\n\t\tgetText,\n\t\tremove,\n\t\tappendText,\n\t\tonStartIndex,\n\t\tonEndIndex,\n\t\tonEmpty,\n\t} = settings;\n\tconst { formats, text, start, end } = value;\n\tconst formatsLength = formats.length + 1;\n\tconst tree = createEmpty( tag );\n\n\tappend( tree, '' );\n\n\tfor ( let i = 0; i < formatsLength; i++ ) {\n\t\tconst character = text.charAt( i );\n\t\tconst characterFormats = formats[ i ];\n\t\tconst lastCharacterFormats = formats[ i - 1 ];\n\n\t\tlet pointer = getLastChild( tree );\n\n\t\tif ( characterFormats ) {\n\t\t\tcharacterFormats.forEach( ( format, formatIndex ) => {\n\t\t\t\tif (\n\t\t\t\t\tpointer &&\n\t\t\t\t\tlastCharacterFormats &&\n\t\t\t\t\tformat === lastCharacterFormats[ formatIndex ]\n\t\t\t\t) {\n\t\t\t\t\tpointer = getLastChild( pointer );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst { type, attributes, object } = format;\n\t\t\t\tconst parent = getParent( pointer );\n\t\t\t\tconst newNode = append( parent, fromFormat( { type, attributes, object } ) );\n\n\t\t\t\tif ( isText( pointer ) && getText( pointer ).length === 0 ) {\n\t\t\t\t\tremove( pointer );\n\t\t\t\t}\n\n\t\t\t\tpointer = append( object ? parent : newNode, '' );\n\t\t\t} );\n\t\t}\n\n\t\t// If there is selection at 0, handle it before characters are inserted.\n\n\t\tif ( onStartIndex && start === 0 && i === 0 ) {\n\t\t\tonStartIndex( tree, pointer, multilineIndex );\n\t\t}\n\n\t\tif ( onEndIndex && end === 0 && i === 0 ) {\n\t\t\tonEndIndex( tree, pointer, multilineIndex );\n\t\t}\n\n\t\tif ( character !== '\\ufffc' ) {\n\t\t\tif ( character === '\\n' ) {\n\t\t\t\tpointer = append( getParent( pointer ), { type: 'br', object: true } );\n\t\t\t\t// Ensure pointer is text node.\n\t\t\t\tpointer = append( getParent( pointer ), '' );\n\t\t\t} else if ( ! isText( pointer ) ) {\n\t\t\t\tpointer = append( getParent( pointer ), character );\n\t\t\t} else {\n\t\t\t\tappendText( pointer, character );\n\t\t\t}\n\t\t}\n\n\t\tif ( onStartIndex && start === i + 1 ) {\n\t\t\tonStartIndex( tree, pointer, multilineIndex );\n\t\t}\n\n\t\tif ( onEndIndex && end === i + 1 ) {\n\t\t\tonEndIndex( tree, pointer, multilineIndex );\n\t\t}\n\t}\n\n\tif ( onEmpty && text.length === 0 ) {\n\t\tonEmpty( tree );\n\t}\n\n\treturn tree;\n}\n","/**\n * Internal dependencies\n */\n\nimport { getActiveFormat } from './get-active-format';\nimport { removeFormat } from './remove-format';\nimport { applyFormat } from './apply-format';\n\n/**\n * Toggles a format object to a Rich Text value at the current selection.\n *\n * @param {Object} value      Value to modify.\n * @param {Object} format     Format to apply or remove.\n *\n * @return {Object} A new value with the format applied or removed.\n */\nexport function toggleFormat(\n\tvalue,\n\tformat\n) {\n\tif ( getActiveFormat( value, format.type ) ) {\n\t\treturn removeFormat( value, format.type );\n\t}\n\n\treturn applyFormat( value, format );\n}\n","/**\n * WordPress dependencies\n */\nimport { select, dispatch } from '@wordpress/data';\n\n/**\n * Unregisters a format.\n *\n * @param {string} name Format name.\n *\n * @return {?WPFormat} The previous format value, if it has been successfully\n *                     unregistered; otherwise `undefined`.\n */\nexport function unregisterFormatType( name ) {\n\tconst oldFormat = select( 'core/rich-text' ).getFormatType( name );\n\n\tif ( ! oldFormat ) {\n\t\twindow.console.error(\n\t\t\t`Format ${ name } is not registered.`\n\t\t);\n\t\treturn;\n\t}\n\n\tdispatch( 'core/rich-text' ).removeFormatTypes( name );\n\n\treturn oldFormat;\n}\n","'use strict';\n\nvar LEAF_KEY, hasWeakMap;\n\n/**\n * Arbitrary value used as key for referencing cache object in WeakMap tree.\n *\n * @type {Object}\n */\nLEAF_KEY = {};\n\n/**\n * Whether environment supports WeakMap.\n *\n * @type {boolean}\n */\nhasWeakMap = typeof WeakMap !== 'undefined';\n\n/**\n * Returns the first argument as the sole entry in an array.\n *\n * @param {*} value Value to return.\n *\n * @return {Array} Value returned as entry in array.\n */\nfunction arrayOf( value ) {\n\treturn [ value ];\n}\n\n/**\n * Returns true if the value passed is object-like, or false otherwise. A value\n * is object-like if it can support property assignment, e.g. object or array.\n *\n * @param {*} value Value to test.\n *\n * @return {boolean} Whether value is object-like.\n */\nfunction isObjectLike( value ) {\n\treturn !! value && 'object' === typeof value;\n}\n\n/**\n * Creates and returns a new cache object.\n *\n * @return {Object} Cache object.\n */\nfunction createCache() {\n\tvar cache = {\n\t\tclear: function() {\n\t\t\tcache.head = null;\n\t\t},\n\t};\n\n\treturn cache;\n}\n\n/**\n * Returns true if entries within the two arrays are strictly equal by\n * reference from a starting index.\n *\n * @param {Array}  a         First array.\n * @param {Array}  b         Second array.\n * @param {number} fromIndex Index from which to start comparison.\n *\n * @return {boolean} Whether arrays are shallowly equal.\n */\nfunction isShallowEqual( a, b, fromIndex ) {\n\tvar i;\n\n\tif ( a.length !== b.length ) {\n\t\treturn false;\n\t}\n\n\tfor ( i = fromIndex; i < a.length; i++ ) {\n\t\tif ( a[ i ] !== b[ i ] ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * Returns a memoized selector function. The getDependants function argument is\n * called before the memoized selector and is expected to return an immutable\n * reference or array of references on which the selector depends for computing\n * its own return value. The memoize cache is preserved only as long as those\n * dependant references remain the same. If getDependants returns a different\n * reference(s), the cache is cleared and the selector value regenerated.\n *\n * @param {Function} selector      Selector function.\n * @param {Function} getDependants Dependant getter returning an immutable\n *                                 reference or array of reference used in\n *                                 cache bust consideration.\n *\n * @return {Function} Memoized selector.\n */\nexport default function( selector, getDependants ) {\n\tvar rootCache, getCache;\n\n\t// Use object source as dependant if getter not provided\n\tif ( ! getDependants ) {\n\t\tgetDependants = arrayOf;\n\t}\n\n\t/**\n\t * Returns the root cache. If WeakMap is supported, this is assigned to the\n\t * root WeakMap cache set, otherwise it is a shared instance of the default\n\t * cache object.\n\t *\n\t * @return {(WeakMap|Object)} Root cache object.\n\t */\n\tfunction getRootCache() {\n\t\treturn rootCache;\n\t}\n\n\t/**\n\t * Returns the cache for a given dependants array. When possible, a WeakMap\n\t * will be used to create a unique cache for each set of dependants. This\n\t * is feasible due to the nature of WeakMap in allowing garbage collection\n\t * to occur on entries where the key object is no longer referenced. Since\n\t * WeakMap requires the key to be an object, this is only possible when the\n\t * dependant is object-like. The root cache is created as a hierarchy where\n\t * each top-level key is the first entry in a dependants set, the value a\n\t * WeakMap where each key is the next dependant, and so on. This continues\n\t * so long as the dependants are object-like. If no dependants are object-\n\t * like, then the cache is shared across all invocations.\n\t *\n\t * @see isObjectLike\n\t *\n\t * @param {Array} dependants Selector dependants.\n\t *\n\t * @return {Object} Cache object.\n\t */\n\tfunction getWeakMapCache( dependants ) {\n\t\tvar caches = rootCache,\n\t\t\tisUniqueByDependants = true,\n\t\t\ti, dependant, map, cache;\n\n\t\tfor ( i = 0; i < dependants.length; i++ ) {\n\t\t\tdependant = dependants[ i ];\n\n\t\t\t// Can only compose WeakMap from object-like key.\n\t\t\tif ( ! isObjectLike( dependant ) ) {\n\t\t\t\tisUniqueByDependants = false;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Does current segment of cache already have a WeakMap?\n\t\t\tif ( caches.has( dependant ) ) {\n\t\t\t\t// Traverse into nested WeakMap.\n\t\t\t\tcaches = caches.get( dependant );\n\t\t\t} else {\n\t\t\t\t// Create, set, and traverse into a new one.\n\t\t\t\tmap = new WeakMap();\n\t\t\t\tcaches.set( dependant, map );\n\t\t\t\tcaches = map;\n\t\t\t}\n\t\t}\n\n\t\t// We use an arbitrary (but consistent) object as key for the last item\n\t\t// in the WeakMap to serve as our running cache.\n\t\tif ( ! caches.has( LEAF_KEY ) ) {\n\t\t\tcache = createCache();\n\t\t\tcache.isUniqueByDependants = isUniqueByDependants;\n\t\t\tcaches.set( LEAF_KEY, cache );\n\t\t}\n\n\t\treturn caches.get( LEAF_KEY );\n\t}\n\n\t// Assign cache handler by availability of WeakMap\n\tgetCache = hasWeakMap ? getWeakMapCache : getRootCache;\n\n\t/**\n\t * Resets root memoization cache.\n\t */\n\tfunction clear() {\n\t\trootCache = hasWeakMap ? new WeakMap() : createCache();\n\t}\n\n\t// eslint-disable-next-line jsdoc/check-param-names\n\t/**\n\t * The augmented selector call, considering first whether dependants have\n\t * changed before passing it to underlying memoize function.\n\t *\n\t * @param {Object} source    Source object for derivation.\n\t * @param {...*}   extraArgs Additional arguments to pass to selector.\n\t *\n\t * @return {*} Selector result.\n\t */\n\tfunction callSelector( /* source, ...extraArgs */ ) {\n\t\tvar len = arguments.length,\n\t\t\tcache, node, i, args, dependants;\n\n\t\t// Create copy of arguments (avoid leaking deoptimization).\n\t\targs = new Array( len );\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\targs[ i ] = arguments[ i ];\n\t\t}\n\n\t\tdependants = getDependants.apply( null, args );\n\t\tcache = getCache( dependants );\n\n\t\t// If not guaranteed uniqueness by dependants (primitive type or lack\n\t\t// of WeakMap support), shallow compare against last dependants and, if\n\t\t// references have changed, destroy cache to recalculate result.\n\t\tif ( ! cache.isUniqueByDependants ) {\n\t\t\tif ( cache.lastDependants && ! isShallowEqual( dependants, cache.lastDependants, 0 ) ) {\n\t\t\t\tcache.clear();\n\t\t\t}\n\n\t\t\tcache.lastDependants = dependants;\n\t\t}\n\n\t\tnode = cache.head;\n\t\twhile ( node ) {\n\t\t\t// Check whether node arguments match arguments\n\t\t\tif ( ! isShallowEqual( node.args, args, 1 ) ) {\n\t\t\t\tnode = node.next;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// At this point we can assume we've found a match\n\n\t\t\t// Surface matched node to head if not already\n\t\t\tif ( node !== cache.head ) {\n\t\t\t\t// Adjust siblings to point to each other.\n\t\t\t\tnode.prev.next = node.next;\n\t\t\t\tif ( node.next ) {\n\t\t\t\t\tnode.next.prev = node.prev;\n\t\t\t\t}\n\n\t\t\t\tnode.next = cache.head;\n\t\t\t\tnode.prev = null;\n\t\t\t\tcache.head.prev = node;\n\t\t\t\tcache.head = node;\n\t\t\t}\n\n\t\t\t// Return immediately\n\t\t\treturn node.val;\n\t\t}\n\n\t\t// No cached value found. Continue to insertion phase:\n\n\t\tnode = {\n\t\t\t// Generate the result from original function\n\t\t\tval: selector.apply( null, args ),\n\t\t};\n\n\t\t// Avoid including the source object in the cache.\n\t\targs[ 0 ] = null;\n\t\tnode.args = args;\n\n\t\t// Don't need to check whether node is already head, since it would\n\t\t// have been returned above already if it was\n\n\t\t// Shift existing head down list\n\t\tif ( cache.head ) {\n\t\t\tcache.head.prev = node;\n\t\t\tnode.next = cache.head;\n\t\t}\n\n\t\tcache.head = node;\n\n\t\treturn node.val;\n\t}\n\n\tcallSelector.getDependants = getDependants;\n\tcallSelector.clear = clear;\n\tclear();\n\n\treturn callSelector;\n}\n","(function() { module.exports = this[\"wp\"][\"data\"]; }());","(function() { module.exports = this[\"wp\"][\"escapeHtml\"]; }());","(function() { module.exports = this[\"lodash\"]; }());"],"sourceRoot":""}